{
  "address": "0x83f37cbF66143e1855Fe0c634Ec6D83e7DBA2CFa",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "underlyingAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "averageMoneyPoolAPR",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalATokenBalanceOfMoneyPool",
          "type": "uint256"
        }
      ],
      "name": "TotalATokenSupplyUpdated",
      "type": "event"
    }
  ],
  "transactionHash": "0x401bfae2bc9acdd9846ec4fa84e887eeb158d149b3144c85dd0d43fa027bb1e0",
  "receipt": {
    "to": null,
    "from": "0x41F82A050De679C2bF59aE81744d48E03cEBeA19",
    "contractAddress": "0x83f37cbF66143e1855Fe0c634Ec6D83e7DBA2CFa",
    "transactionIndex": 3,
    "gasUsed": "72217",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5ed1dfdf5a2413a1d6c50f98cf471809dc771dd64f632236ab87f01b72ff3256",
    "transactionHash": "0x401bfae2bc9acdd9846ec4fa84e887eeb158d149b3144c85dd0d43fa027bb1e0",
    "logs": [],
    "blockNumber": 25313952,
    "cumulativeGasUsed": "858963",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "6384bc112e4cb10a01932abc66540276",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"averageMoneyPoolAPR\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalATokenBalanceOfMoneyPool\",\"type\":\"uint256\"}],\"name\":\"TotalATokenSupplyUpdated\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/logic/AssetBond.sol\":\"AssetBond\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/libraries/DataStruct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPR;\\n    uint256 supplyAPR;\\n    uint256 totalDepositedAssetBondCount;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityDate The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    address asset;\\n    address borrower;\\n    address lawfirm;\\n    string ipfsHash; // refactor : gas\\n    uint256 collateralValue;\\n    uint256 borrowAPR;\\n    uint256 sign; // refactor : apply oz - sign\\n    uint256 issuanceDate;\\n    uint256 dueDate;\\n    uint256 maturityDate;\\n    uint256 lastUpdateTimestamp;\\n    AssetBondState state;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * MATURED:\\n   */\\n  enum AssetBondState {EMPTY, SETTLED, CONFIRMED, COLLATERALIZED, MATURED, NOT_PERFORMED}\\n\\n  struct TokenizerData {\\n    address asset;\\n    uint256 averageATokenAPR;\\n    uint256 totalATokenSupply;\\n    uint256 lastUpdateTimestamp;\\n  }\\n}\\n\",\"keccak256\":\"0xcbcc25b812cd805fa7a93882b934912fe797dc7c9f3298a5256f2c00eb6e2833\",\"license\":\"MIT\"},\"contracts/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Errors library\\n * @author ELYSIA\\n * @dev Custom error messages\\n */\\nlibrary MoneyPoolErrors {\\n  //// error DigitalAssetAlreadyAdded(address asset);\\n  //// error MaxDigitalAssetCountExceeded();\\n  //// error ReservePaused();\\n  //// error ReserveInactivated();\\n  //// error InvalidAmount(uint256 amount);\\n  //// error WithdrawInsufficientBalance(uint256 amount, uint256 userLTokenBalance);\\n  //// error MaturedABToken();\\n  //// error NotDepositedABToken();\\n  //// error NotSettledABToken(uint256 id);\\n  //// error NotSignedABToken(uint256 id);\\n  //// error InsufficientATokenBalance(uint256 totalDepositedATokenBalance);\\n}\\n\\nlibrary TokenErrors {\\n  //// error OnlyMoneyPool();\\n  //// error InvalidMintAmount(uint256 implicitBalance);\\n  //// error InvalidBurnAmount(uint256 implicitBalance);\\n}\\n\",\"keccak256\":\"0x016602f902c9c00d204ef44e9302c5d8391e7f42d08c3b2d9971a8da83d03eff\",\"license\":\"MIT\"},\"contracts/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary Math {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant SECONDSPERYEAR = 365 days;\\n\\n  function calculateLinearInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\\n  }\\n\\n  /**\\n   * @notice Author : AAVE\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  function calculateRateInIncreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountIn,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\\n\\n    uint256 newTotalBalance = totalBalance + amountIn;\\n    uint256 newAverageRate =\\n      (weightedAverageRate + weightedAmountRate).rayDiv(newTotalBalance.wadToRay());\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n\\n  function calculateRateInDecreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountOut,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    // if decreasing amount exceeds totalBalance,\\n    // overall rate and balacne would be set 0\\n    if (totalBalance <= amountOut) {\\n      return (0, 0);\\n    }\\n\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\\n\\n    if (weightedAverageRate <= weightedAmountRate) {\\n      return (0, 0);\\n    }\\n\\n    uint256 newTotalBalance = totalBalance - amountOut;\\n\\n    uint256 newAverageRate =\\n      (weightedAverageRate - weightedAmountRate).rayDiv(newTotalBalance.wadToRay());\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n}\\n\",\"keccak256\":\"0xebae42da2552f1e57165d35de647e8ea02a83762096ad52194ebe2f7490a5039\",\"license\":\"MIT\"},\"contracts/libraries/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xc6970a03f4b670dce12693422c436b79b4ae8659ed3e3d4d7173ad8b91cb8cb5\",\"license\":\"MIT\"},\"contracts/logic/AssetBond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport '../libraries/DataStruct.sol';\\nimport '../libraries/Errors.sol';\\nimport '../libraries/Math.sol';\\nimport '../libraries/WadRayMath.sol';\\n\\nlibrary AssetBond {\\n  using WadRayMath for uint256;\\n  using AssetBond for DataStruct.AssetBondData;\\n\\n  event TotalATokenSupplyUpdated(\\n    address underlyingAsset,\\n    uint256 id,\\n    uint256 averageMoneyPoolAPR,\\n    uint256 totalATokenBalanceOfMoneyPool\\n  );\\n\\n  //   uint256 constant COUNTRY_CODE =\\n  //   uint256 constant CSP_IDENTIFICATION_NUMBER = ;\\n  //   uint256 constant COLLATERAL_LATITUDE = ;\\n  //   uint256 constant COLLATERAL_LONGITUDE = ;\\n  //   uint256 constant COLLATERAL_DETAILS = ;\\n  //   uint256 constant NONCE = ;\\n  //   uint256 constant ??? = ;\\n  //   uint256 constant COLLATERAL_CATEGORY = ;\\n\\n  // uint256 constant COUNTRY_CODE_START= 0;\\n  // uint256 constant CSP_IDENTIFICATION_NUMBER_START= 3;\\n  // uint256 constant COLLATERAL_LATITUDE_START= 18;\\n  // uint256 constant COLLATERAL_LONGITUDE_START= 30;\\n  // uint256 constant COLLATERAL_DETAILS_START= 42;\\n  // uint256 constant NONCE_START= 52;\\n  // uint256 constant \\ub300\\ucd9c\\uc0c1\\ud488\\ubc88\\ud638_START= 55;\\n  // uint256 constant COLLATERAL_CATEGOR_START= 60;\\n  function settleAssetBond(\\n    DataStruct.AssetBondData storage assetBondData,\\n    address asset,\\n    address borrower,\\n    address lawfirm,\\n    uint256 collateralValue,\\n    uint256 dueDate,\\n    string memory ipfsHash\\n  ) internal {\\n    assetBondData.asset = asset;\\n    assetBondData.borrower = borrower;\\n    assetBondData.lawfirm = lawfirm;\\n    assetBondData.collateralValue = collateralValue;\\n    assetBondData.dueDate = dueDate;\\n    assetBondData.ipfsHash = ipfsHash;\\n    assetBondData.lastUpdateTimestamp = block.timestamp;\\n    assetBondData.state = DataStruct.AssetBondState.SETTLED;\\n  }\\n\\n  function collateralizeAssetBond(\\n    DataStruct.AssetBondData storage assetBondData,\\n    uint256 borrowAmount,\\n    uint256 borrowAPR\\n  ) internal {\\n    // update tokenizer data\\n    //reserve.totalDepositedAssetBondCount += 1;\\n\\n    // set bond date data\\n    assetBondData.borrowAPR = borrowAPR;\\n    assetBondData.state = DataStruct.AssetBondState.COLLATERALIZED;\\n    assetBondData.lastUpdateTimestamp = block.timestamp;\\n    assetBondData.issuanceDate = block.timestamp;\\n    assetBondData.maturityDate = block.timestamp + (assetBondData.dueDate * 1 days);\\n  }\\n\\n  function releaseAssetBond(DataStruct.AssetBondData storage assetBondData) internal {\\n    assetBondData.state = DataStruct.AssetBondState.MATURED;\\n  }\\n\\n  function validateSettleABToken(uint256 tokenId, address lawfirm) internal view {\\n    // checks whether lawfirm authorized\\n    // if (assetBond.state != AssetBondState.EMPTY) revert(); ////\\n    // access control : check lawfirm\\n  }\\n\\n  function validateTokenId(uint256 id) internal {\\n    // validate id\\n    //// error InvalidABTokenID(id)\\n  }\\n}\\n\",\"keccak256\":\"0xf06b5ac04cfd922b0b6bdcb3e19ecacf78476015a3583ea5f1aced8c71a76cbf\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122032ae247ef501e7867dd849813855bc5159b92db0fdfee2cba758b4147cbe512864736f6c63430008040033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122032ae247ef501e7867dd849813855bc5159b92db0fdfee2cba758b4147cbe512864736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}