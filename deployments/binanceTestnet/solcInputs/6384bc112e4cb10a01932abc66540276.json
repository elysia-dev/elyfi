{
  "language": "Solidity",
  "sources": {
    "contracts/Connector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './libraries/Role.sol';\nimport './ConnectorStorage.sol';\nimport './interfaces/IConnector.sol';\n\n/**\n * @title ELYFI Connector\n * @author ELYSIA\n */\ncontract Connector is IConnector, ConnectorStorage {\n  constructor() {}\n\n  function addCouncil(address account) external {\n    _grantRole(Role.COUNCIL, account);\n    emit NewCouncilAdded(account);\n  }\n\n  function addCSP(address account) external {\n    _grantRole(Role.CSP, account);\n    emit NewCSPAdded(account);\n  }\n\n  function setAdmin(address account) external {\n    _grantRole(Role.MONEYPOOL_ADMIN, account);\n    emit UpdateAdmin(account);\n  }\n\n  function _grantRole(bytes32 role, address account) internal {\n    _roles[role].participants[account] = true;\n  }\n\n  function _revokeRole(bytes32 role, address account) internal {\n    _roles[role].participants[account] = false;\n  }\n\n  function _hasRole(bytes32 role, address account) internal view returns (bool) {\n    return _roles[role].participants[account];\n  }\n\n  function isMoneyPool(address account) external view override returns (bool) {}\n\n  function isCSP(address account) external view override returns (bool) {}\n\n  function isCouncil(address account) external view override returns (bool) {}\n}\n"
    },
    "contracts/libraries/Role.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title ELYFI Role\n * @author ELYSIA\n */\nlibrary Role {\n  bytes32 internal constant CSP = 'CSP';\n  bytes32 internal constant COUNCIL = 'COUNCIL';\n  bytes32 internal constant MONEYPOOL_ADMIN = 'MONEYPOOL_ADMIN';\n}\n"
    },
    "contracts/ConnectorStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title ELYFI Connector storage\n * @author ELYSIA\n */\ncontract ConnectorStorage {\n  struct RoleData {\n    mapping(address => bool) participants;\n    bytes32 admin;\n  }\n\n  mapping(bytes32 => RoleData) internal _roles;\n}\n"
    },
    "contracts/interfaces/IConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IConnector {\n  event NewCouncilAdded(address indexed account);\n  event NewCSPAdded(address indexed account);\n  event UpdateAdmin(address indexed account);\n\n  function isMoneyPool(address account) external view returns (bool);\n\n  function isCSP(address account) external view returns (bool);\n\n  function isCouncil(address account) external view returns (bool);\n}\n"
    },
    "contracts/libraries/DataStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nlibrary DataStruct {\n  /**\n    @notice The main reserve data struct.\n   */\n  struct ReserveData {\n    uint256 moneyPoolFactor;\n    uint256 lTokenInterestIndex;\n    uint256 borrowAPR;\n    uint256 supplyAPR;\n    uint256 totalDepositedAssetBondCount;\n    uint256 lastUpdateTimestamp;\n    address lTokenAddress;\n    address dTokenAddress;\n    address interestModelAddress;\n    address tokenizerAddress;\n    uint8 id;\n    bool isPaused;\n    bool isActivated;\n  }\n\n  /**\n   * @notice The asset bond data struct.\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\n   * between Collateral Service Provider and lender.\n   * @param maturityDate The amount of time measured in seconds that can elapse\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\n   * @param borrower The address of the borrower.\n   */\n  struct AssetBondData {\n    address asset;\n    address borrower;\n    address lawfirm;\n    string ipfsHash; // refactor : gas\n    uint256 collateralValue;\n    uint256 borrowAPR;\n    uint256 sign; // refactor : apply oz - sign\n    uint256 issuanceDate;\n    uint256 dueDate;\n    uint256 maturityDate;\n    uint256 lastUpdateTimestamp;\n    AssetBondState state;\n  }\n\n  /**\n    @notice The states of asset bond\n    * EMPTY: After\n    * SETTLED:\n    * CONFIRMED:\n    * COLLATERALIZED:\n    * MATURED:\n   */\n  enum AssetBondState {EMPTY, SETTLED, CONFIRMED, COLLATERALIZED, MATURED, NOT_PERFORMED}\n\n  struct TokenizerData {\n    address asset;\n    uint256 averageATokenAPR;\n    uint256 totalATokenSupply;\n    uint256 lastUpdateTimestamp;\n  }\n}\n"
    },
    "contracts/test/ConnectorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../Connector.sol';\n\ncontract ConnectorTest is Connector {\n  constructor() {}\n}\n"
    },
    "contracts/TokenizerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './libraries/DataStruct.sol';\nimport './logic/Index.sol';\nimport './interfaces/IConnector.sol';\n\ncontract TokenizerStorage {\n  using Index for DataStruct.ReserveData;\n\n  IConnector internal _connector;\n\n  mapping(uint256 => bytes32) internal _tokenType;\n\n  mapping(uint256 => address) internal _minter;\n\n  address internal _underlyingAsset;\n\n  DataStruct.TokenizerData internal _tokenizerData;\n\n  /// @notice A mapping from an asset bond's identifier to the asset bond data struct.\n  /// The token id is a unique identifier for asset bond.\n  mapping(uint256 => DataStruct.AssetBondData) internal _assetBondData;\n}\n"
    },
    "contracts/logic/Index.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Errors.sol';\nimport '../libraries/Math.sol';\nimport 'hardhat/console.sol';\n\nlibrary Index {\n  using WadRayMath for uint256;\n  using Index for DataStruct.ReserveData;\n\n  /**\n   * @dev Returns the ongoing normalized income for the reserve\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n   * @param reserve The reserve object\n   * @return the normalized income. expressed in ray\n   **/\n  function getLTokenInterestIndex(DataStruct.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 lastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    if (lastUpdateTimestamp == block.timestamp) {\n      return reserve.lTokenInterestIndex;\n    }\n\n    uint256 newIndex =\n      Math.calculateLinearInterest(reserve.supplyAPR, lastUpdateTimestamp, block.timestamp).rayMul(\n        reserve.lTokenInterestIndex\n      );\n\n    return newIndex;\n  }\n\n  function updateState(DataStruct.ReserveData storage reserve) internal {\n    uint256 previousLTokenIndex = reserve.lTokenInterestIndex;\n    uint256 lastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    updateIndexes(reserve, previousLTokenIndex, lastUpdateTimestamp);\n\n    // _mintToReserveFactor\n  }\n\n  /**\n   * @dev Updates the reserve indexes and the timestamp\n   * @param reserve The reserve to be updated\n   * @param lTokenIndex The last updated lToken Index\n   * @param timeStamp The last updated timestamp\n   **/\n  function updateIndexes(\n    DataStruct.ReserveData storage reserve,\n    uint256 lTokenIndex,\n    uint256 timeStamp\n  ) internal returns (uint256) {\n    uint256 currentSupplyAPR = reserve.supplyAPR;\n\n    if (currentSupplyAPR == 0) {\n      reserve.lastUpdateTimestamp = block.timestamp;\n      return (lTokenIndex);\n    }\n\n    reserve.lTokenInterestIndex = getLTokenInterestIndex(reserve);\n\n    reserve.lastUpdateTimestamp = block.timestamp;\n\n    console.log(\n      'hardhat updateIndex console: lToken index | timestamp',\n      reserve.lTokenInterestIndex,\n      reserve.lastUpdateTimestamp\n    );\n\n    return (reserve.lTokenInterestIndex);\n  }\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title Errors library\n * @author ELYSIA\n * @dev Custom error messages\n */\nlibrary MoneyPoolErrors {\n  //// error DigitalAssetAlreadyAdded(address asset);\n  //// error MaxDigitalAssetCountExceeded();\n  //// error ReservePaused();\n  //// error ReserveInactivated();\n  //// error InvalidAmount(uint256 amount);\n  //// error WithdrawInsufficientBalance(uint256 amount, uint256 userLTokenBalance);\n  //// error MaturedABToken();\n  //// error NotDepositedABToken();\n  //// error NotSettledABToken(uint256 id);\n  //// error NotSignedABToken(uint256 id);\n  //// error InsufficientATokenBalance(uint256 totalDepositedATokenBalance);\n}\n\nlibrary TokenErrors {\n  //// error OnlyMoneyPool();\n  //// error InvalidMintAmount(uint256 implicitBalance);\n  //// error InvalidBurnAmount(uint256 implicitBalance);\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './WadRayMath.sol';\n\nlibrary Math {\n  using WadRayMath for uint256;\n\n  uint256 internal constant SECONDSPERYEAR = 365 days;\n\n  function calculateLinearInterest(\n    uint256 rate,\n    uint256 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\n  }\n\n  /**\n   * @notice Author : AAVE\n   * @dev Function to calculate the interest using a compounded interest rate formula\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n   *\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n   *\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate compounded during the timeDelta, in ray\n   **/\n  function calculateCompoundedInterest(\n    uint256 rate,\n    uint256 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    if (exp == 0) {\n      return WadRayMath.ray();\n    }\n\n    uint256 expMinusOne = exp - 1;\n\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\n\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\n  }\n\n  function calculateRateInIncreasingBalance(\n    uint256 averageRate,\n    uint256 totalBalance,\n    uint256 amountIn,\n    uint256 rate\n  ) internal pure returns (uint256, uint256) {\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\n\n    uint256 newTotalBalance = totalBalance + amountIn;\n    uint256 newAverageRate =\n      (weightedAverageRate + weightedAmountRate).rayDiv(newTotalBalance.wadToRay());\n\n    return (newTotalBalance, newAverageRate);\n  }\n\n  function calculateRateInDecreasingBalance(\n    uint256 averageRate,\n    uint256 totalBalance,\n    uint256 amountOut,\n    uint256 rate\n  ) internal pure returns (uint256, uint256) {\n    // if decreasing amount exceeds totalBalance,\n    // overall rate and balacne would be set 0\n    if (totalBalance <= amountOut) {\n      return (0, 0);\n    }\n\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\n\n    if (weightedAverageRate <= weightedAmountRate) {\n      return (0, 0);\n    }\n\n    uint256 newTotalBalance = totalBalance - amountOut;\n\n    uint256 newAverageRate =\n      (weightedAverageRate - weightedAmountRate).rayDiv(newTotalBalance.wadToRay());\n\n    return (newTotalBalance, newAverageRate);\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant halfWAD = WAD / 2;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @return One ray, 1e27\n   **/\n  function ray() internal pure returns (uint256) {\n    return RAY;\n  }\n\n  /**\n   * @return One wad, 1e18\n   **/\n\n  function wad() internal pure returns (uint256) {\n    return WAD;\n  }\n\n  /**\n   * @return Half ray, 1e27/2\n   **/\n  function halfRay() internal pure returns (uint256) {\n    return halfRAY;\n  }\n\n  /**\n   * @return Half ray, 1e18/2\n   **/\n  function halfWad() internal pure returns (uint256) {\n    return halfWAD;\n  }\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a*b, in wad\n   **/\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    return (a * b + halfWAD) / WAD;\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a/b, in wad\n   **/\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, 'Division by Zero');\n    uint256 halfB = b / 2;\n    return (a * WAD + halfB) / b;\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a*b, in ray\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    return (a * b + halfRAY) / RAY;\n  }\n\n  /**\n   * @dev Divides two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a/b, in ray\n   **/\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, 'Division by Zero');\n    uint256 halfB = b / 2;\n    return (a * RAY + halfB) / b;\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @param a Ray\n   * @return a casted to wad, rounded half up to the nearest wad\n   **/\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\n    uint256 result = halfRatio + a;\n    return result / WAD_RAY_RATIO;\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @param a Wad\n   * @return a converted in ray\n   **/\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    uint256 result = a * WAD_RAY_RATIO;\n    return result;\n  }\n}\n"
    },
    "contracts/Tokenizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport './libraries/WadRayMath.sol';\nimport './libraries/Errors.sol';\nimport './libraries/DataStruct.sol';\nimport './libraries/Math.sol';\nimport './libraries/Role.sol';\nimport './logic/AssetBond.sol';\nimport './logic/TokenizerData.sol';\nimport './logic/Index.sol';\nimport './logic/Validation.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/ITokenizer.sol';\nimport './interfaces/IConnector.sol';\nimport './TokenizerStorage.sol';\nimport 'hardhat/console.sol';\n\n/**\n * @title ELYFI Tokenizer\n * @author ELYSIA\n */\ncontract Tokenizer is ITokenizer, TokenizerStorage, ERC721 {\n  using WadRayMath for uint256;\n  using TokenizerData for DataStruct.TokenizerData;\n  using AssetBond for DataStruct.AssetBondData;\n  using Index for DataStruct.AssetBondData;\n\n  /************ Initialize Functions ************/\n\n  constructor(\n    address connector,\n    string memory name_,\n    string memory symbol_\n  ) ERC721(name_, symbol_) {\n    _connector = IConnector(connector);\n  }\n\n  /************ View Functions ************/\n\n  /**\n   * @dev Returns the state of the asset bond\n   * @param tokenId The asset bond tokenId\n   * @return The data of the asset bond\n   **/\n  function getAssetBondData(uint256 tokenId)\n    external\n    view\n    override\n    returns (DataStruct.AssetBondData memory)\n  {\n    return _assetBondData[tokenId];\n  }\n\n  function getTokenizerData() external view override returns (DataStruct.TokenizerData memory) {\n    return _tokenizerData;\n  }\n\n  function getMinter(uint256 tokenId) external view returns (address) {\n    return _minter[tokenId];\n  }\n\n  /************ ABToken Formation Functions ************/\n\n  // tokenId : bitMask\n  /**\n   * @notice This function can be called by collateral service providers when they want to sign a contract.\n   * Borrowers who wants to take out a loan backed by real asset must enter into a contract\n   * with a collateral service provider to obtain a loan. Borrowers should submit various documents necessary for evaluating a loan secured by\n   * real assets to the collateral service provider.\n   * @param account CSP address\n   * @param tokenId The tokenId is a unique identifier for asset bond.\n   */\n  function mintABToken(address account, uint256 tokenId) external override onlyCSP {\n    if (_minter[tokenId] != address(0)) revert(); ////error ABTokenIDAlreadyExist(tokenId);\n    if (!_connector.isCSP(account)) revert(); ////error MintedABTokenReceiverNotAllowed(account, tokenId);\n\n    // validate tokenId : tokenId should have information about\n    AssetBond.validateTokenId(tokenId);\n\n    // mint ABToken to CSP\n    _safeMint(account, tokenId, '');\n\n    _minter[tokenId] = account;\n\n    emit EmptyABTokenMinted(account, tokenId);\n  }\n\n  // Access control : only minter\n  /**\n   * @notice This function is called after Based on the documents submitted by the loan applicant,\n   * risk analysis for the relevant asset is conducted, and the loan availability,\n   * maximum loanable amount and the interest rate between collateral service provider\n   * and borrower are calculated.\n   * @param borrower borrower\n   * @param tokenId tokenId\n   * @param collateralValue collateralValue in USD\n   */\n  function settleABToken(\n    address asset,\n    address borrower,\n    address lawfirm,\n    uint256 tokenId,\n    uint256 collateralValue,\n    uint256 dueDate,\n    string memory ipfsHash\n  ) external {\n    // Validate init asset bond\n    // lawfirm should be authorized\n    // Asset bond state should be empty\n    AssetBond.validateSettleABToken(tokenId, lawfirm);\n\n    _assetBondData[tokenId].settleAssetBond(\n      asset,\n      borrower,\n      lawfirm,\n      collateralValue,\n      dueDate,\n      ipfsHash\n    );\n  }\n\n  function signABToken(uint256 tokenId, address signer) external {}\n\n  function collateralizeAssetBond(\n    address account,\n    uint256 tokenId,\n    uint256 borrowAmount,\n    uint256 borrowAPR\n  ) external override onlyMoneyPool {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n\n    assetBond.collateralizeAssetBond(borrowAmount, borrowAPR);\n\n    console.log(\n      'hardhat deposit ABToken Tokenizer | borrowAPR | totalSupply | averageATokenAPR',\n      borrowAPR,\n      _tokenizerData.totalATokenSupply,\n      _tokenizerData.averageATokenAPR\n    );\n  }\n\n  function releaseAssetBond(address account, uint256 tokenId) external override onlyMoneyPool {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n  }\n\n  /************ Token Functions ************/\n\n  /************ MoneyPool Total AToken Balance Manage Functions ************/\n\n  // need logic : generate tokenId\n  function _generateATokenId(uint256 assetBondId) internal pure returns (uint256) {\n    return assetBondId * 10;\n  }\n\n  modifier onlyMoneyPool {\n    if (!_connector.isMoneyPool((msg.sender))) revert(); ////OnlyMoneyPool();\n    _;\n  }\n\n  modifier onlyCSP {\n    if (!_connector.isCSP(msg.sender)) revert(); ////OnlyCSP();\n    _;\n  }\n\n  modifier onlyCouncil {\n    if (!_connector.isCouncil(msg.sender)) revert(); ////OnlyCouncil();\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "contracts/logic/AssetBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Errors.sol';\nimport '../libraries/Math.sol';\nimport '../libraries/WadRayMath.sol';\n\nlibrary AssetBond {\n  using WadRayMath for uint256;\n  using AssetBond for DataStruct.AssetBondData;\n\n  event TotalATokenSupplyUpdated(\n    address underlyingAsset,\n    uint256 id,\n    uint256 averageMoneyPoolAPR,\n    uint256 totalATokenBalanceOfMoneyPool\n  );\n\n  //   uint256 constant COUNTRY_CODE =\n  //   uint256 constant CSP_IDENTIFICATION_NUMBER = ;\n  //   uint256 constant COLLATERAL_LATITUDE = ;\n  //   uint256 constant COLLATERAL_LONGITUDE = ;\n  //   uint256 constant COLLATERAL_DETAILS = ;\n  //   uint256 constant NONCE = ;\n  //   uint256 constant ??? = ;\n  //   uint256 constant COLLATERAL_CATEGORY = ;\n\n  // uint256 constant COUNTRY_CODE_START= 0;\n  // uint256 constant CSP_IDENTIFICATION_NUMBER_START= 3;\n  // uint256 constant COLLATERAL_LATITUDE_START= 18;\n  // uint256 constant COLLATERAL_LONGITUDE_START= 30;\n  // uint256 constant COLLATERAL_DETAILS_START= 42;\n  // uint256 constant NONCE_START= 52;\n  // uint256 constant 대출상품번호_START= 55;\n  // uint256 constant COLLATERAL_CATEGOR_START= 60;\n  function settleAssetBond(\n    DataStruct.AssetBondData storage assetBondData,\n    address asset,\n    address borrower,\n    address lawfirm,\n    uint256 collateralValue,\n    uint256 dueDate,\n    string memory ipfsHash\n  ) internal {\n    assetBondData.asset = asset;\n    assetBondData.borrower = borrower;\n    assetBondData.lawfirm = lawfirm;\n    assetBondData.collateralValue = collateralValue;\n    assetBondData.dueDate = dueDate;\n    assetBondData.ipfsHash = ipfsHash;\n    assetBondData.lastUpdateTimestamp = block.timestamp;\n    assetBondData.state = DataStruct.AssetBondState.SETTLED;\n  }\n\n  function collateralizeAssetBond(\n    DataStruct.AssetBondData storage assetBondData,\n    uint256 borrowAmount,\n    uint256 borrowAPR\n  ) internal {\n    // update tokenizer data\n    //reserve.totalDepositedAssetBondCount += 1;\n\n    // set bond date data\n    assetBondData.borrowAPR = borrowAPR;\n    assetBondData.state = DataStruct.AssetBondState.COLLATERALIZED;\n    assetBondData.lastUpdateTimestamp = block.timestamp;\n    assetBondData.issuanceDate = block.timestamp;\n    assetBondData.maturityDate = block.timestamp + (assetBondData.dueDate * 1 days);\n  }\n\n  function releaseAssetBond(DataStruct.AssetBondData storage assetBondData) internal {\n    assetBondData.state = DataStruct.AssetBondState.MATURED;\n  }\n\n  function validateSettleABToken(uint256 tokenId, address lawfirm) internal view {\n    // checks whether lawfirm authorized\n    // if (assetBond.state != AssetBondState.EMPTY) revert(); ////\n    // access control : check lawfirm\n  }\n\n  function validateTokenId(uint256 id) internal {\n    // validate id\n    //// error InvalidABTokenID(id)\n  }\n}\n"
    },
    "contracts/logic/TokenizerData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Errors.sol';\nimport '../libraries/Math.sol';\nimport '../libraries/WadRayMath.sol';\n\nlibrary TokenizerData {\n  using WadRayMath for uint256;\n  using TokenizerData for DataStruct.TokenizerData;\n\n  event MoneyPoolATokenDataUpdated(\n    address underlyingAsset,\n    uint256 id,\n    uint256 averageATokenAPR,\n    uint256 totalATokenBalanceOfMoneyPool\n  );\n\n  event TotalATokenUpdated(\n    address underlyingAsset,\n    uint256 averageATokenAPR,\n    uint256 totalATokenSupply\n  );\n\n  struct IncreaseATokenBalanceLocalVars {\n    uint256 newAverageATokenAPR;\n    uint256 newBalance;\n  }\n\n  function increaseTotalATokenSupply(\n    DataStruct.TokenizerData storage tokenizerData,\n    uint256 amountIn,\n    uint256 rate\n  ) internal {\n    IncreaseATokenBalanceLocalVars memory vars;\n\n    (vars.newBalance, vars.newAverageATokenAPR) = Math.calculateRateInIncreasingBalance(\n      tokenizerData.averageATokenAPR,\n      tokenizerData.totalATokenSupply,\n      amountIn,\n      rate\n    );\n\n    tokenizerData.averageATokenAPR = vars.newAverageATokenAPR;\n    tokenizerData.totalATokenSupply = vars.newBalance;\n    tokenizerData.lastUpdateTimestamp = block.timestamp;\n\n    emit TotalATokenUpdated(tokenizerData.asset, vars.newAverageATokenAPR, vars.newBalance);\n  }\n\n  struct DecreaseATokenBalanceLocalVars {\n    uint256 newAverageATokenAPR;\n    uint256 newBalance;\n  }\n\n  function decreaseTotalATokenSupply(\n    DataStruct.TokenizerData storage tokenizerData,\n    uint256 amountOut,\n    uint256 rate\n  ) internal {\n    IncreaseATokenBalanceLocalVars memory vars;\n\n    (vars.newBalance, vars.newAverageATokenAPR) = Math.calculateRateInDecreasingBalance(\n      tokenizerData.averageATokenAPR,\n      tokenizerData.totalATokenSupply,\n      amountOut,\n      rate\n    );\n\n    tokenizerData.averageATokenAPR = vars.newAverageATokenAPR;\n    tokenizerData.totalATokenSupply = vars.newBalance;\n\n    emit TotalATokenUpdated(tokenizerData.asset, vars.newAverageATokenAPR, vars.newBalance);\n  }\n\n  function validateSettleABToken(uint256 tokenId, address lawfirm) internal view {\n    // checks whether lawfirm authorized\n    // if (assetBond.state != AssetBondState.EMPTY) revert(); ////\n    // access control : check lawfirm\n  }\n\n  function validateTokenId(uint256 id) internal {\n    // validate id\n    //// error InvalidABTokenID(id)\n  }\n}\n"
    },
    "contracts/logic/Validation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Errors.sol';\nimport '../libraries/Math.sol';\nimport '../interfaces/ILToken.sol';\n\nlibrary Validation {\n  using WadRayMath for uint256;\n  using Validation for DataStruct.ReserveData;\n\n  /**\n   * @dev Validate Invest\n   * Check reserve state\n   * @param reserve The reserve object\n   * @param amount Investment amount\n   **/\n  function validateInvestMoneyPool(DataStruct.ReserveData storage reserve, uint256 amount)\n    internal\n    view\n  {\n    if (amount == 0) revert(); //// InvalidAmount(amount)\n\n    if (reserve.isPaused == true) revert(); //// ReservePaused();\n\n    if (reserve.isActivated == false) revert(); //// ReserveInactivated();\n  }\n\n  /**\n   * @dev Validate WithdrawMoneyPool\n   * Check reserve state\n   * Check user amount\n   * Check user total debt(later)\n   * @param reserve The reserve object\n   * @param underlyingAsset Underlying asset address\n   * @param amount Withdraw amount\n   * @param reserveList reserve list for calculating user total debt\n   * @param reserveCount reserve count for iteration\n   **/\n  function validateWithdrawMoneyPool(\n    DataStruct.ReserveData storage reserve,\n    address underlyingAsset,\n    uint256 amount,\n    uint256 userLTokenBalance,\n    mapping(uint256 => address) storage reserveList,\n    uint256 reserveCount\n  ) internal view {\n    if (amount == 0) revert(); //// InvalidAmount(amount)\n    if (reserve.isPaused == true) revert(); //// ReservePaused();\n    if (reserve.isActivated == false) revert(); //// ReserveInactivated();\n    if (amount > userLTokenBalance) revert(); //// WithdrawInsufficientBalance(amount, userLTokenBalance);\n  }\n\n  /**\n   * @dev Validate invest ABToken\n   * Check reserve state\n   * Check ABToken state\n   * Check user amount\n   * Check user total debt(later)\n   * @param reserve The reserve object\n   * @param assetBond The assetBond object\n   * @param amount Withdraw amount\n   **/\n  function validateInvestABToken(\n    DataStruct.ReserveData storage reserve,\n    DataStruct.AssetBondData memory assetBond,\n    uint256 amount,\n    uint256 moneyPoolATokenBalance\n  ) internal view {\n    if (amount == 0) revert(); //// InvalidAmount(amount)\n    if (reserve.isPaused == true) revert(); //// ReservePaused();\n    if (reserve.isActivated == false) revert(); //// ReserveInactivated();\n\n    //if(assetBond.isMatured == true) revert(); //// MaturedABToken();\n    //if(assetBond.isDeposited == false) revert(); //// NotDepositedABToken();\n    if (moneyPoolATokenBalance < amount) revert(); //// InsufficientATokenBalance(reserve.totalDepositedATokenBalance);\n  }\n\n  function validateBorrowAgainstAssetBond(\n    DataStruct.ReserveData storage reserve,\n    DataStruct.AssetBondData memory assetBond,\n    address asset,\n    uint256 borrowAmount\n  ) internal view {\n    // moneypool validate logic : active, frozen\n\n    // check settled logic\n    //if (assetBond.isSettled == true) revert(); //// NotSettledABToken(id);\n\n    // check sign logic\n    //if (assetBond.isSigned == false) revert(); ////NotSignedABToken(id);\n\n    uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.lTokenAddress);\n  }\n\n  function validateLTokenTrasfer() internal pure {}\n}\n"
    },
    "contracts/interfaces/IMoneyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IMoneyPool {\n  event InvestMoneyPool(address indexed asset, address indexed account, uint256 amount);\n\n  event WithdrawMoneyPool(\n    address indexed asset,\n    address indexed account,\n    address indexed to,\n    uint256 amount\n  );\n\n  event BorrowAgainstAssetBond(\n    address indexed asset,\n    address indexed borrower,\n    address indexed receiver,\n    uint256 tokenId,\n    uint256 borrowAPR,\n    uint256 borrowAmount\n  );\n\n  event RepayAgainstAssetBond();\n\n  function investMoneyPool(\n    address asset,\n    address account,\n    uint256 amount\n  ) external;\n\n  function withdrawMoneyPool(\n    address asset,\n    address account,\n    uint256 amount\n  ) external returns (uint256);\n\n  function borrowAgainstABToken(\n    address asset,\n    address receiver,\n    uint256 borrowAmount,\n    uint256 tokenID\n  ) external;\n\n  function getLTokenInterestIndex(address asset) external view returns (uint256);\n\n  function getReserveData(address asset) external view returns (DataStruct.ReserveData memory);\n\n  function validateLTokenTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 previousFromBalance,\n    uint256 previousToBalance\n  ) external;\n\n  function addNewReserve(\n    address asset,\n    address lToken,\n    address dToken,\n    address interestModel,\n    address tokenizer,\n    uint256 moneyPoolFactor_\n  ) external;\n}\n"
    },
    "contracts/interfaces/ITokenizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\n\ninterface ITokenizer {\n  event EmptyABTokenMinted(address indexed account, uint256 tokenId);\n\n  event Invest(address indexed asset, address indexed account, uint256 amount);\n\n  event Withdraw(\n    address indexed asset,\n    address indexed account,\n    address indexed to,\n    uint256 amount\n  );\n\n  function mintABToken(\n    address account,\n    uint256 id // information about Co and borrower\n  ) external;\n\n  function getTokenizerData() external view returns (DataStruct.TokenizerData memory);\n\n  function getAssetBondData(uint256 tokenId)\n    external\n    view\n    returns (DataStruct.AssetBondData memory);\n\n  function collateralizeAssetBond(\n    address account,\n    uint256 tokenId,\n    uint256 borrowAmount,\n    uint256 borrowAPR\n  ) external;\n\n  function releaseAssetBond(address account, uint256 tokenId) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface ILToken is IERC20 {\n  /**\n   * @dev Emitted after lTokens are minted\n   * @param account The receiver of minted lToken\n   * @param amount The amount being minted\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed account, uint256 amount, uint256 index);\n\n  /**\n   * @dev Emitted after lTokens are burned\n   * @param account The owner of the lTokens, getting them burned\n   * @param underlyingAssetReceiver The address that will receive the underlying asset\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(\n    address indexed account,\n    address indexed underlyingAssetReceiver,\n    uint256 amount,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param account The account whose tokens are being transferred\n   * @param to The recipient\n   * @param amount The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed account, address indexed to, uint256 amount, uint256 index);\n\n  function mint(\n    address account,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Burns lTokens account `account` and sends the equivalent amount of underlying to `receiver`\n   * @param account The owner of the lTokens, getting them burned\n   * @param receiver The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Returns the address of the underlying asset of this LTokens (E.g. WETH for aWETH)\n   **/\n  function getUnderlyingAsset() external view returns (address);\n\n  function implicitBalanceOf(address account) external view returns (uint256);\n\n  function implicitTotalSupply() external view returns (uint256);\n\n  function transferUnderlyingTo(address underlyingAssetReceiver, uint256 amount)\n    external\n    returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/MoneyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './MoneyPoolStorage.sol';\nimport './interfaces/ILToken.sol';\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/ITokenizer.sol';\nimport './logic/Index.sol';\nimport './logic/Rate.sol';\nimport './logic/AssetBond.sol';\nimport './logic/Validation.sol';\nimport './libraries/DataStruct.sol';\nimport 'hardhat/console.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n/**\n * @title Main contract for ELYFI beta. This contract manages the ability\n * to invest and withdraw cryptocurrency and create NFT-backed loans.\n * @author ELYSIA\n * @notice This contract is beta version of ELYFI. The investor and borrower\n * should approve the ELYFI moneypool contract to move their AssetBond token\n * or ERC20 tokens on their behalf.\n **/\ncontract MoneyPool is IMoneyPool, MoneyPoolStorage {\n  using SafeERC20 for IERC20;\n  using Index for DataStruct.ReserveData;\n  using Validation for DataStruct.ReserveData;\n  using Rate for DataStruct.ReserveData;\n  using AssetBond for DataStruct.AssetBondData;\n\n  constructor(uint256 maxReserveCount_, address connector) {\n    _connector = connector;\n    _maxReserveCount = maxReserveCount_;\n    _reserveCount += 1;\n  }\n\n  /************ MoneyPool Investment Functions ************/\n\n  /**\n   * @dev Invests an amount of underlying asset and receive corresponding LTokens.\n   * @param asset The address of the underlying asset to invest\n   * @param account The address that will receive the LToken\n   * @param amount Investment amount\n   **/\n  function investMoneyPool(\n    address asset,\n    address account,\n    uint256 amount\n  ) external override {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n\n    // validation\n    // Check pool activation\n    Validation.validateInvestMoneyPool(reserve, amount);\n\n    // update indexes and mintToReserve\n    reserve.updateState();\n\n    // update rates\n    reserve.updateRates(asset, amount, 0);\n\n    // transfer underlying asset\n    // If transfer fail, reverts\n    IERC20(asset).safeTransferFrom(msg.sender, reserve.lTokenAddress, amount);\n\n    // Mint ltoken\n    ILToken(reserve.lTokenAddress).mint(account, amount, reserve.lTokenInterestIndex);\n\n    console.log(\n      'Invest finalize |amount|lTokenInterestIndex|borrowAPR',\n      amount,\n      reserve.lastUpdateTimestamp,\n      reserve.borrowAPR\n    );\n    emit InvestMoneyPool(asset, account, amount);\n  }\n\n  /**\n   * @dev Withdraws an amount of underlying asset from the reserve and burns the corresponding lTokens.\n   * @param asset The address of the underlying asset to withdraw\n   * @param account The address that will receive the underlying asset\n   * @param amount Withdrawl amount\n   **/\n  function withdrawMoneyPool(\n    address asset,\n    address account,\n    uint256 amount\n  ) external override returns (uint256) {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n\n    uint256 userLTokenBalance = ILToken(reserve.lTokenAddress).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = amount;\n\n    if (amount == type(uint256).max) {\n      amountToWithdraw == userLTokenBalance;\n    }\n\n    // validation\n    // Without digital asset borrow, validation might be quite simple.\n    Validation.validateWithdrawMoneyPool(\n      reserve,\n      asset,\n      amount,\n      userLTokenBalance,\n      _reservesList,\n      _reserveCount\n    );\n\n    // update indexes and mintToReserve\n    reserve.updateState();\n\n    // update rates\n    reserve.updateRates(asset, 0, amountToWithdraw);\n\n    // Burn ltoken\n    ILToken(reserve.lTokenAddress).burn(\n      msg.sender,\n      account,\n      amountToWithdraw,\n      reserve.lTokenInterestIndex\n    );\n\n    console.log(\n      'Borrow finalize |amount|lastUpdateTimestamp|borrowAPR',\n      amountToWithdraw,\n      reserve.lTokenInterestIndex,\n      reserve.borrowAPR\n    );\n\n    emit WithdrawMoneyPool(asset, msg.sender, account, amountToWithdraw);\n  }\n\n  /************ ABToken Formation Functions ************/\n\n  // need access control signer: only lawfirm or asset owner\n  // need access control : only minter\n\n  /**\n   * @dev Withdraws an amount of underlying asset from the reserve and burns the corresponding lTokens.\n   * @notice\n   * @param asset The address of the underlying asset to withdraw\n   * @param receiver The address that will receive the underlying asset\n   * @param borrowAmount borrowAmount\n   **/\n  function borrowAgainstABToken(\n    address asset,\n    address receiver,\n    uint256 borrowAmount,\n    uint256 tokenId\n  ) external override {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    DataStruct.AssetBondData memory assetBond =\n      ITokenizer(reserve.tokenizerAddress).getAssetBondData(tokenId);\n\n    // Check if borrow amount exceeds collateral value\n    // Check if borrow amount exceeds liquidity available\n    Validation.validateBorrowAgainstAssetBond(reserve, assetBond, asset, borrowAmount);\n\n    reserve.updateState();\n\n    // update interest rate\n\n    ITokenizer(reserve.tokenizerAddress).collateralizeAssetBond(\n      msg.sender,\n      tokenId,\n      borrowAmount,\n      reserve.borrowAPR\n    );\n\n    // transfer asset bond\n    // or lock NFT?\n\n    IDToken(reserve.dTokenAddress).mint(msg.sender, receiver, borrowAmount, reserve.borrowAPR);\n\n    reserve.updateRates(asset, 0, borrowAmount);\n\n    // transfer Underlying asset\n    ILToken(reserve.lTokenAddress).transferUnderlyingTo(receiver, borrowAmount);\n\n    console.log(\n      'Borrow finalize |amount|lastUpdateTimestamp|borrowAPR',\n      borrowAmount,\n      reserve.lastUpdateTimestamp,\n      reserve.borrowAPR\n    );\n\n    emit BorrowAgainstAssetBond(\n      asset,\n      msg.sender,\n      receiver,\n      tokenId,\n      reserve.borrowAPR,\n      borrowAmount\n    );\n  }\n\n  function retrieveAssetBond(\n    address asset,\n    address receiver,\n    uint256 repayAmount,\n    uint256 tokenId\n  ) external {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    DataStruct.AssetBondData memory assetBond =\n      ITokenizer(reserve.tokenizerAddress).getAssetBondData(tokenId);\n  }\n\n  /************ View Functions ************/\n\n  /**\n   * @dev Returns LToken Interest index of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The LToken interest index of reserve\n   */\n  function getLTokenInterestIndex(address asset) external view override returns (uint256) {\n    return _reserves[asset].getLTokenInterestIndex();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    override\n    returns (DataStruct.ReserveData memory)\n  {\n    return _reserves[asset];\n  }\n\n  /************ External Functions ************/\n\n  /**\n   * @dev Validate and finalize LToken transfer\n   * @notice In beta version, there's no need for validation\n   */\n  function validateLTokenTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 previousFromBalance,\n    uint256 previousToBalance\n  ) external override {\n    if (msg.sender == _reserves[asset].lTokenAddress) revert(); ////\n\n    // For beta version, there's no need for validate LToken transfer\n    Validation.validateLTokenTrasfer();\n  }\n\n  /************ Configuration Functions ************/\n\n  // Need access control, onlyConfigurator can add new reserve.\n  function addNewReserve(\n    address asset,\n    address lToken,\n    address dToken,\n    address interestModel,\n    address tokenizer,\n    uint256 moneyPoolFactor_\n  ) external override {\n    DataStruct.ReserveData memory newReserveData =\n      DataStruct.ReserveData({\n        moneyPoolFactor: moneyPoolFactor_,\n        lTokenInterestIndex: WadRayMath.ray(),\n        borrowAPR: 0,\n        supplyAPR: 0,\n        totalDepositedAssetBondCount: 0,\n        lastUpdateTimestamp: block.timestamp,\n        lTokenAddress: lToken,\n        dTokenAddress: dToken,\n        interestModelAddress: interestModel,\n        tokenizerAddress: tokenizer,\n        id: 0,\n        isPaused: false,\n        isActivated: true\n      });\n\n    _reserves[asset] = newReserveData;\n    _addNewReserveToList(asset);\n  }\n\n  function _addNewReserveToList(address asset) internal {\n    uint256 reserveCount = _reserveCount;\n\n    if (reserveCount >= _maxReserveCount) revert(); ////MaxReserveCountExceeded();\n\n    if (_reserves[asset].id != 0) revert(); ////DigitalAssetAlreadyAdded(address asset);\n\n    _reserves[asset].id = uint8(reserveCount);\n    _reservesList[reserveCount] = asset;\n\n    _reserveCount = reserveCount + 1;\n  }\n}\n"
    },
    "contracts/MoneyPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './libraries/DataStruct.sol';\nimport './logic/Index.sol';\n\ncontract MoneyPoolStorage {\n  using Index for DataStruct.ReserveData;\n\n  mapping(address => DataStruct.ReserveData) internal _reserves;\n\n  mapping(uint256 => address) internal _reservesList;\n\n  uint256 internal _reserveCount;\n\n  uint256 internal _maxReserveCount;\n\n  address internal _connector;\n}\n"
    },
    "contracts/interfaces/IDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\ninterface IDToken is IERC20Metadata {\n  /**\n   * @dev Emitted when new stable debt is minted\n   * @param account The address of the account who triggered the minting\n   * @param receiver The recipient of stable debt tokens\n   * @param amount The amount minted\n   * @param currentBalance The current balance of the account\n   * @param balanceIncrease The increase in balance since the last action of the account\n   * @param newRate The rate of the debt after the minting\n   * @param avgStableRate The new average stable rate after the minting\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Mint(\n    address indexed account,\n    address indexed receiver,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 newRate,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Emitted when new stable debt is burned\n   * @param account The address of the account\n   * @param amount The amount being burned\n   * @param currentBalance The current balance of the account\n   * @param balanceIncrease The the increase in balance since the last action of the account\n   * @param avgStableRate The new average stable rate after the burning\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Burn(\n    address indexed account,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Mints debt token to the `receiver` address.\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `receiver` otherwise\n   * @param receiver The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 rate\n  ) external returns (bool);\n\n  /**\n   * @dev Burns debt of `account`\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param account The address of the account getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address account, uint256 amount) external;\n\n  /**\n   * @dev Returns the average rate of all the stable rate loans.\n   * @return The average stable rate\n   **/\n  function getTotalAverageRealAssetBorrowRate() external view returns (uint256);\n\n  /**\n   * @dev Returns the stable rate of the account debt\n   * @return The stable rate of the account\n   **/\n  function getUserAverageRealAssetBorrowRate(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the timestamp of the last update of the account\n   * @return The timestamp\n   **/\n  function getUserLastUpdateTimestamp(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the principal, the total supply and the average stable rate\n   **/\n  function getDTokenData()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /**\n   * @dev Returns the timestamp of the last update of the total supply\n   * @return The timestamp\n   **/\n  function getTotalSupplyLastUpdated() external view returns (uint256);\n\n  /**\n   * @dev Returns the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the principal debt balance of the account\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function principalBalanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/logic/Rate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Errors.sol';\nimport '../libraries/Math.sol';\nimport '../interfaces/ILToken.sol';\nimport '../interfaces/IDToken.sol';\nimport '../interfaces/ITokenizer.sol';\nimport '../interfaces/IInterestRateModel.sol';\n\nlibrary Rate {\n  using WadRayMath for uint256;\n  using Rate for DataStruct.ReserveData;\n\n  event MoneyPoolRatesUpdated(\n    address indexed underlyingAssetAddress,\n    uint256 lTokenIndex,\n    uint256 borrowAPR,\n    uint256 supplyAPR\n  );\n\n  struct UpdateRatesLocalVars {\n    uint256 totalDToken;\n    uint256 newBorrowAPR;\n    uint256 newSupplyAPR;\n    uint256 averageBorrowAPR;\n    uint256 totalVariableDebt;\n  }\n\n  function updateRates(\n    DataStruct.ReserveData storage reserve,\n    address underlyingAssetAddress,\n    uint256 investAmount,\n    uint256 borrowAmount\n  ) internal {\n    UpdateRatesLocalVars memory vars;\n\n    vars.totalDToken = IDToken(reserve.dTokenAddress).totalSupply();\n\n    vars.averageBorrowAPR = IDToken(reserve.dTokenAddress).getTotalAverageRealAssetBorrowRate();\n\n    (vars.newBorrowAPR, vars.newSupplyAPR) = IInterestRateModel(reserve.interestModelAddress)\n      .calculateRates(\n      underlyingAssetAddress,\n      reserve.lTokenAddress,\n      vars.totalDToken,\n      investAmount,\n      borrowAmount,\n      vars.averageBorrowAPR,\n      reserve.moneyPoolFactor\n    );\n\n    reserve.borrowAPR = vars.newBorrowAPR;\n    reserve.supplyAPR = vars.newSupplyAPR;\n\n    emit MoneyPoolRatesUpdated(\n      underlyingAssetAddress,\n      reserve.lTokenInterestIndex,\n      vars.newBorrowAPR,\n      vars.newSupplyAPR\n    );\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IInterestRateModel {\n  function calculateRates(\n    address asset,\n    address lToken,\n    uint256 totalDTokenBalance,\n    uint256 investAmount,\n    uint256 borrowAmount,\n    uint256 averageBorrowAPR,\n    uint256 moneyPoolFactor\n  ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/test/MoneyPoolTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../MoneyPool.sol';\n\ncontract MoneyPoolTest is MoneyPool {\n  constructor(uint256 maxReserveCount_, address connector) MoneyPool(maxReserveCount_, connector) {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract ERC20Test is ERC20 {\n  constructor(\n    uint256 totalSupply_,\n    string memory name_,\n    string memory symbol_\n  ) ERC20(name_, symbol_) {\n    _mint(msg.sender, totalSupply_);\n  }\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './InterestRateModelStorage.sol';\nimport './libraries/WadRayMath.sol';\nimport './interfaces/IInterestRateModel.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport 'hardhat/console.sol';\n\n/**\n * @title ELYFI InterestRateModel\n * @author ELYSIA\n */\ncontract InterestRateModel is IInterestRateModel, InterestRateModelStorage {\n  using WadRayMath for uint256;\n\n  constructor(\n    uint256 optimalUtilizationRate,\n    uint256 borrowRateBase,\n    uint256 borrowRateOptimal,\n    uint256 borrowRateMax\n  ) {\n    _optimalUtilizationRate = optimalUtilizationRate;\n    _borrowRateBase = borrowRateBase;\n    _borrowRateOptimal = borrowRateOptimal;\n    _borrowRateMax = borrowRateMax;\n  }\n\n  struct calculateRatesLocalVars {\n    uint256 totalDebt;\n    uint256 utilizationRate;\n    uint256 newBorrowAPR;\n    uint256 newSupplyAPR;\n  }\n\n  function calculateRates(\n    address asset,\n    address lToken,\n    uint256 totalDTokenBalance,\n    uint256 investAmount,\n    uint256 borrowAmount,\n    uint256 averageBorrowAPR,\n    uint256 moneyPoolFactor\n  ) public view override returns (uint256, uint256) {\n    calculateRatesLocalVars memory vars;\n\n    vars.totalDebt = totalDTokenBalance;\n\n    uint256 availableLiquidity = IERC20(asset).balanceOf(lToken) + investAmount - borrowAmount;\n\n    vars.utilizationRate = vars.totalDebt == 0\n      ? 0\n      : vars.totalDebt.rayDiv(availableLiquidity + vars.totalDebt);\n\n    vars.newBorrowAPR = 0;\n\n    // Example\n    // Case1: under optimal U\n    // baseRate = 2%, util = 40%, optimalRate = 10%, optimalUtil = 80%\n    // result = 2+40*(10-2)/80 = 4%\n    // Case2: over optimal U\n    // optimalRate = 10%, util = 90%, maxRate = 100%, optimalUtil = 80%\n    // result = 10+(90-80)*(100-10)/(100-80) = 55%\n    if (vars.utilizationRate <= _optimalUtilizationRate) {\n      vars.newBorrowAPR =\n        _borrowRateBase +\n        (\n          (_borrowRateOptimal - _borrowRateBase).rayDiv(_optimalUtilizationRate).rayMul(\n            vars.utilizationRate\n          )\n        );\n    } else {\n      vars.newBorrowAPR =\n        _borrowRateOptimal +\n        (\n          (_borrowRateMax - _borrowRateOptimal)\n            .rayDiv(WadRayMath.ray() - _optimalUtilizationRate)\n            .rayMul(vars.utilizationRate - _borrowRateOptimal)\n        );\n    }\n\n    vars.newSupplyAPR = vars.newBorrowAPR.rayMul(vars.utilizationRate);\n    // need reserveFactor calculation\n\n    console.log(\n      'hardhat interest Rate Model console: totalDebt-Util',\n      vars.totalDebt,\n      vars.utilizationRate\n    );\n\n    console.log(\n      'hardhat interest Rate Model console: Borrow | Supply',\n      vars.newBorrowAPR,\n      vars.newSupplyAPR\n    );\n\n    return (vars.newBorrowAPR, vars.newSupplyAPR);\n  }\n}\n"
    },
    "contracts/InterestRateModelStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title ELYFI InterestRateModel\n * @author ELYSIA\n */\ncontract InterestRateModelStorage {\n  uint256 internal _optimalUtilizationRate;\n\n  uint256 internal _borrowRateBase;\n\n  uint256 internal _borrowRateOptimal;\n\n  uint256 internal _borrowRateMax;\n}\n"
    },
    "contracts/test/IndexTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../logic/Index.sol';\nimport '../MoneyPoolStorage.sol';\n\ncontract IndexTest is MoneyPoolStorage {\n  using Index for DataStruct.ReserveData;\n\n  function getLTokenInterestIndex(address asset) public view returns (uint256) {\n    return _reserves[asset].getLTokenInterestIndex();\n  }\n\n  function updateState(address asset) public {\n    return _reserves[asset].updateState();\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) public view returns (DataStruct.ReserveData memory) {\n    return _reserves[asset];\n  }\n}\n"
    },
    "contracts/LToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport './libraries/WadRayMath.sol';\nimport './libraries/Errors.sol';\nimport './interfaces/ILToken.sol';\nimport './interfaces/IMoneyPool.sol';\n\n/**\n * @title ELYFI LToken\n * @author ELYSIA\n */\ncontract LToken is ILToken, ERC20 {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IMoneyPool internal _moneyPool;\n  address internal _underlyingAsset;\n\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) ERC20(name_, symbol_) {\n    _moneyPool = moneyPool;\n    _underlyingAsset = underlyingAsset_;\n  }\n\n  function mint(\n    address account,\n    uint256 amount,\n    uint256 index\n  ) external override onlyMoneyPool returns (bool) {\n    uint256 implicitBalance = amount.rayDiv(index);\n\n    if (amount == 0) revert(); ////InvalidMintAmount(uint256 implicitBalance);\n\n    _mint(account, implicitBalance);\n\n    emit Transfer(address(0), account, amount);\n    emit Mint(account, amount, index);\n  }\n\n  function burn(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 index\n  ) external override onlyMoneyPool {\n    uint256 implicitBalance = amount.rayDiv(index);\n\n    if (amount == 0) revert(); ////InvalidBurnAmount(uint256 implicitBalance);\n\n    _burn(account, implicitBalance);\n\n    IERC20(_underlyingAsset).safeTransfer(receiver, amount);\n\n    emit Burn(account, receiver, amount, index);\n  }\n\n  /**\n   * @return Returns implicit balance multipied by ltoken interest index\n   **/\n  function balanceOf(address account) public view override(IERC20, ERC20) returns (uint256) {\n    return super.balanceOf(account).rayMul(_moneyPool.getLTokenInterestIndex(_underlyingAsset));\n  }\n\n  function implicitBalanceOf(address account) external view override returns (uint256) {\n    return super.balanceOf(account);\n  }\n\n  function implicitTotalSupply() public view override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  function totalSupply() public view override(IERC20, ERC20) returns (uint256) {\n    return super.totalSupply().rayMul(_moneyPool.getLTokenInterestIndex(_underlyingAsset));\n  }\n\n  /**\n   * @dev Transfers the underlying asset to receiver.\n   * @param receiver The recipient of the underlying asset\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address receiver, uint256 amount)\n    external\n    override\n    onlyMoneyPool\n    returns (uint256)\n  {\n    IERC20(_underlyingAsset).safeTransfer(receiver, amount);\n    return amount;\n  }\n\n  /**\n   * @dev Transfers LToken\n   * @param from The from address\n   * @param to The recipient of LToken\n   * @param amount The amount getting transferred, but actual amount is implicit balance\n   * @param validate If true, validate and finalize transfer\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount,\n    bool validate\n  ) internal {\n    uint256 index = _moneyPool.getLTokenInterestIndex(_underlyingAsset);\n\n    uint256 previousFromBalance = super.balanceOf(from).rayMul(index);\n    uint256 previousToBalance = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      _moneyPool.validateLTokenTransfer(\n        _underlyingAsset,\n        from,\n        to,\n        amount,\n        previousFromBalance,\n        previousToBalance\n      );\n    }\n  }\n\n  /**\n   * @dev Overriding ERC20 _transfer for reflecting implicit balance\n   * @param from The from address\n   * @param to The recipient of LToken\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    _transfer(from, to, amount, true);\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function getUnderlyingAsset() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  modifier onlyMoneyPool {\n    if (_msgSender() != address(_moneyPool)) revert(); ////OnlyMoneyPool();\n    _;\n  }\n}\n"
    },
    "contracts/test/LTokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../LToken.sol';\n\ncontract LTokenTest is LToken {\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) LToken(moneyPool, underlyingAsset_, name_, symbol_) {}\n}\n"
    },
    "contracts/DToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\nimport './libraries/WadRayMath.sol';\nimport './libraries/Math.sol';\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\n/**\n * @title DToken\n * @notice The DToken balance of borrower is the amount of money that the borrower\n * would be required to repay and seize the collateralized asset bond token.\n *\n * @author Aave\n **/\ncontract DToken is IDToken, Context {\n  using WadRayMath for uint256;\n\n  uint256 internal _totalAverageRealAssetBorrowRate;\n  mapping(address => uint256) internal _userLastUpdateTimestamp;\n  mapping(address => uint256) internal _userAverageRealAssetBorrowRate;\n  uint256 internal _lastUpdateTimestamp;\n\n  uint256 internal _totalSupply;\n  mapping(address => uint256) internal _balances;\n\n  string private _name;\n  string private _symbol;\n\n  IMoneyPool internal _moneyPool;\n  address internal _underlyingAsset;\n\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) {\n    _moneyPool = moneyPool;\n    _underlyingAsset = underlyingAsset_;\n\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the decimals of the token.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    revert(); //// DTokenTransferNotAllowed();\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    revert(); ////DTokenTransferFromNotAllowed();\n  }\n\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    revert(); //// DTokenAllowanceNotAllowed();\n  }\n\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    revert(); //// DTokenApproveTransferNotAllowed();\n  }\n\n  /**\n   * @dev Returns the average stable rate across all the stable rate debt\n   * @return the average stable rate\n   **/\n  function getTotalAverageRealAssetBorrowRate() external view virtual override returns (uint256) {\n    return _totalAverageRealAssetBorrowRate;\n  }\n\n  /**\n   * @dev Returns the timestamp of the last account action\n   * @return The last update timestamp\n   **/\n  function getUserLastUpdateTimestamp(address account)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _userLastUpdateTimestamp[account];\n  }\n\n  /**\n   * @dev Returns the stable rate of the account\n   * @param account The address of the account\n   * @return The stable rate of account\n   **/\n  function getUserAverageRealAssetBorrowRate(address account)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _userAverageRealAssetBorrowRate[account];\n  }\n\n  /**\n   * @dev Calculates the current account debt balance\n   * @return The accumulated debt of the account\n   **/\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    uint256 accountBalance = _balances[account];\n    uint256 stableRate = _userAverageRealAssetBorrowRate[account];\n    if (accountBalance == 0) {\n      return 0;\n    }\n    uint256 cumulatedInterest =\n      Math.calculateCompoundedInterest(\n        stableRate,\n        _userLastUpdateTimestamp[account],\n        block.timestamp\n      );\n    return accountBalance.rayMul(cumulatedInterest);\n  }\n\n  struct MintLocalVars {\n    uint256 previousSupply;\n    uint256 nextSupply;\n    uint256 amountInRay;\n    uint256 newStableRate;\n    uint256 currentAvgStableRate;\n  }\n\n  /**\n   * @dev Mints debt token to the `receiver` address.\n   * -  Only callable by the LendingPool\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the principal debt\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `receiver` otherwise\n   * @param receiver The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 rate\n  ) external override onlyMoneyPool returns (bool) {\n    MintLocalVars memory vars;\n\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(receiver);\n\n    vars.previousSupply = totalSupply();\n    vars.currentAvgStableRate = _totalAverageRealAssetBorrowRate;\n    vars.nextSupply = _totalSupply = vars.previousSupply + amount;\n\n    vars.amountInRay = amount.wadToRay();\n\n    (, vars.newStableRate) = Math.calculateRateInIncreasingBalance(\n      _userAverageRealAssetBorrowRate[receiver],\n      currentBalance,\n      amount,\n      rate\n    );\n\n    _userAverageRealAssetBorrowRate[receiver] = vars.newStableRate;\n\n    //solium-disable-next-line\n    _lastUpdateTimestamp = _userLastUpdateTimestamp[receiver] = block.timestamp;\n\n    // Calculates the updated average stable rate\n    (, vars.currentAvgStableRate) = Math.calculateRateInIncreasingBalance(\n      vars.currentAvgStableRate,\n      vars.previousSupply,\n      amount,\n      rate\n    );\n\n    _totalAverageRealAssetBorrowRate = vars.currentAvgStableRate;\n\n    _mint(receiver, amount + balanceIncrease);\n\n    emit Transfer(address(0), receiver, amount);\n\n    emit Mint(\n      account,\n      receiver,\n      amount,\n      currentBalance,\n      balanceIncrease,\n      vars.newStableRate,\n      vars.currentAvgStableRate,\n      vars.nextSupply\n    );\n\n    return currentBalance == 0;\n  }\n\n  /**\n   * @dev Burns debt of `account`\n   * @param account The address of the account getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address account, uint256 amount) external override onlyMoneyPool {\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(account);\n\n    uint256 previousSupply = totalSupply();\n    uint256 newAvgStableRate = 0;\n    uint256 nextSupply = 0;\n    uint256 userStableRate = _userAverageRealAssetBorrowRate[account];\n\n    // Since the total supply and each single account debt accrue separately,\n    // there might be accumulation errors so that the last borrower repaying\n    // mght actually try to repay more than the available debt supply.\n    // In this case we simply set the total supply and the avg stable rate to 0\n    if (previousSupply <= amount) {\n      _totalAverageRealAssetBorrowRate = 0;\n      _totalSupply = 0;\n    } else {\n      nextSupply = _totalSupply = previousSupply - amount;\n      uint256 firstTerm = _totalAverageRealAssetBorrowRate.rayMul(previousSupply.wadToRay());\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n      // For the same reason described above, when the last account is repaying it might\n      // happen that account rate * account balance > avg rate * total supply. In that case,\n      // we simply set the avg rate to 0\n      if (secondTerm >= firstTerm) {\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = _totalSupply = 0;\n      } else {\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = (firstTerm - secondTerm).rayDiv(\n          nextSupply.wadToRay()\n        );\n      }\n    }\n\n    if (amount == currentBalance) {\n      _userAverageRealAssetBorrowRate[account] = 0;\n      _userLastUpdateTimestamp[account] = 0;\n    } else {\n      //solium-disable-next-line\n      _userLastUpdateTimestamp[account] = block.timestamp;\n    }\n    //solium-disable-next-line\n    _lastUpdateTimestamp = block.timestamp;\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      _mint(account, amountToMint);\n      emit Mint(\n        account,\n        account,\n        amountToMint,\n        currentBalance,\n        balanceIncrease,\n        userStableRate,\n        newAvgStableRate,\n        nextSupply\n      );\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      _burn(account, amountToBurn);\n      emit Burn(\n        account,\n        amountToBurn,\n        currentBalance,\n        balanceIncrease,\n        newAvgStableRate,\n        nextSupply\n      );\n    }\n\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Calculates the increase in balance since the last account interaction\n   * @param account The address of the account for which the interest is being accumulated\n   * @return The principal principal balance, the new principal balance and the balance increase\n   **/\n  function _calculateBalanceIncrease(address account)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 previousPrincipalBalance = _balances[account];\n\n    if (previousPrincipalBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    // Calculation of the accrued interest since the last accumulation\n    uint256 balanceIncrease = balanceOf(account) - previousPrincipalBalance;\n\n    return (previousPrincipalBalance, previousPrincipalBalance + balanceIncrease, balanceIncrease);\n  }\n\n  /**\n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n   **/\n  function getDTokenData()\n    public\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\n    return (_totalSupply, _calcTotalSupply(avgRate), avgRate, _lastUpdateTimestamp);\n  }\n\n  /**\n   * @dev Returns the the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\n    return (_calcTotalSupply(avgRate), avgRate);\n  }\n\n  /**\n   * @dev Returns the total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    return _calcTotalSupply(_totalAverageRealAssetBorrowRate);\n  }\n\n  /**\n   * @dev Returns the timestamp at which the total supply was updated\n   **/\n  function getTotalSupplyLastUpdated() public view override returns (uint256) {\n    return _lastUpdateTimestamp;\n  }\n\n  /**\n   * @dev Returns the principal debt balance of the account from\n   * @param account The account's address\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function principalBalanceOf(address account) external view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this aToken is used\n   **/\n  function POOL() public view returns (IMoneyPool) {\n    return _moneyPool;\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contracts\n   **/\n  function _getMoneyPool() internal view returns (IMoneyPool) {\n    return _moneyPool;\n  }\n\n  /**\n   * @dev Calculates the total supply\n   * @param avgRate The average rate at which the total supply increases\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n    uint256 principalSupply = _totalSupply;\n\n    if (principalSupply == 0) {\n      return 0;\n    }\n\n    uint256 cumulatedInterest =\n      Math.calculateCompoundedInterest(avgRate, _lastUpdateTimestamp, block.timestamp);\n\n    return principalSupply.rayMul(cumulatedInterest);\n  }\n\n  /**\n   * @dev Mints stable debt tokens to an account\n   * @param account The account receiving the debt tokens\n   * @param amount The amount being minted\n   **/\n  function _mint(address account, uint256 amount) internal {\n    uint256 oldAccountBalance = _balances[account];\n    _balances[account] = oldAccountBalance + amount;\n  }\n\n  /**\n   * @dev Burns stable debt tokens of an account\n   * @param account The account getting his debt burned\n   * @param amount The amount being burned\n   **/\n  function _burn(address account, uint256 amount) internal {\n    uint256 oldAccountBalance = _balances[account];\n    _balances[account] = oldAccountBalance - amount;\n  }\n\n  modifier onlyMoneyPool {\n    if (_msgSender() != address(_moneyPool)) revert(); ////OnlyMoneyPool();\n    _;\n  }\n}\n"
    },
    "contracts/test/DTokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../DToken.sol';\n\ncontract DTokenTest is DToken {\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) DToken(moneyPool, underlyingAsset_, name_, symbol_) {}\n}\n"
    },
    "contracts/DataPipeline.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport './interfaces/ILToken.sol';\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/ITokenizer.sol';\nimport './libraries/DataStruct.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract DataPipeline {\n  IMoneyPool public moneyPool;\n\n  constructor(address moneyPool_) {\n    moneyPool = IMoneyPool(moneyPool_);\n  }\n\n  struct UserDataLocalVars {\n    uint256 underlyingAssetBalance;\n    uint256 lTokenBalance;\n    uint256 implicitLtokenBalance;\n    uint256 dTokenBalance;\n    uint256 principalDTokenBalance;\n    uint256 averageRealAssetBorrowRate;\n    uint256 lastUpdateTimestamp;\n  }\n\n  function getUserData(address asset, address user)\n    external\n    view\n    returns (UserDataLocalVars memory)\n  {\n    UserDataLocalVars memory vars;\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n\n    vars.underlyingAssetBalance = IERC20(asset).balanceOf(user);\n    vars.lTokenBalance = ILToken(reserve.lTokenAddress).balanceOf(user);\n    vars.implicitLtokenBalance = ILToken(reserve.lTokenAddress).implicitBalanceOf(user);\n    vars.dTokenBalance = IDToken(reserve.dTokenAddress).balanceOf(user);\n    vars.principalDTokenBalance = IDToken(reserve.dTokenAddress).principalBalanceOf(user);\n    vars.averageRealAssetBorrowRate = IDToken(reserve.dTokenAddress)\n      .getUserAverageRealAssetBorrowRate(user);\n    vars.lastUpdateTimestamp = IDToken(reserve.dTokenAddress).getUserLastUpdateTimestamp(user);\n\n    return vars;\n  }\n\n  struct ReserveDataLocalVars {\n    uint256 totalLTokenSupply;\n    uint256 implicitLTokenSupply;\n    uint256 lTokenInterestIndex;\n    uint256 principalDTokenSupply;\n    uint256 totalDTokenSupply;\n    uint256 averageRealAssetBorrowRate;\n    uint256 dTokenLastUpdateTimestamp;\n    uint256 borrowAPR;\n    uint256 supplyAPR;\n    uint256 moneyPooLastUpdateTimestamp;\n  }\n\n  function getReserveData(address asset) external view returns (ReserveDataLocalVars memory) {\n    ReserveDataLocalVars memory vars;\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n\n    vars.totalLTokenSupply = ILToken(reserve.lTokenAddress).totalSupply();\n    vars.implicitLTokenSupply = ILToken(reserve.lTokenAddress).implicitTotalSupply();\n    vars.lTokenInterestIndex = reserve.lTokenInterestIndex;\n    (\n      vars.principalDTokenSupply,\n      vars.totalDTokenSupply,\n      vars.averageRealAssetBorrowRate,\n      vars.dTokenLastUpdateTimestamp\n    ) = IDToken(reserve.dTokenAddress).getDTokenData();\n    vars.borrowAPR = reserve.borrowAPR;\n    vars.supplyAPR = reserve.supplyAPR;\n    vars.moneyPooLastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    return vars;\n  }\n\n  struct AssetBondDataLocalVars {\n    uint256 tokenId;\n    uint256 aTokenBalance;\n    address tokenOwner;\n    DataStruct.AssetBondState state;\n  }\n\n  function getAssetBondData(address asset, uint256 tokenId)\n    external\n    view\n    returns (AssetBondDataLocalVars memory)\n  {\n    AssetBondDataLocalVars memory vars;\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n    ITokenizer tokenizer = ITokenizer(reserve.tokenizerAddress);\n    vars.tokenId = tokenId;\n    //vars.aTokenBalance\n\n    return vars;\n  }\n}\n"
    },
    "contracts/test/TokenizerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport '../Tokenizer.sol';\n\ncontract TokenizerTest is Tokenizer {\n  constructor(\n    address connector,\n    string memory name_,\n    string memory symbol_\n  ) Tokenizer(connector, name_, symbol_) {}\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}