{
  "address": "0x9Eb704b380E6caE794af479796866A264F87Aa79",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lTokenIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lastUpdateTimestamp",
          "type": "uint256"
        }
      ],
      "name": "LTokenIndexUpdated",
      "type": "event"
    }
  ],
  "transactionHash": "0xf107321b3b116377dafbaf150e354729d94143e19c88ba5c6728426e6a774d0e",
  "receipt": {
    "to": null,
    "from": "0x715B006d4723977CcDb1581a62948f6354752e62",
    "contractAddress": "0x9Eb704b380E6caE794af479796866A264F87Aa79",
    "transactionIndex": 71,
    "gasUsed": "168514",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xacead22b2abfea699c58a137bfe3a80aed8f2f85abf3d7689416f5451e8d98d9",
    "transactionHash": "0xf107321b3b116377dafbaf150e354729d94143e19c88ba5c6728426e6a774d0e",
    "logs": [],
    "blockNumber": 12830630,
    "cumulativeGasUsed": "5485672",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "0c71cd98fa6269b62417fa18d1fc6779",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lTokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"name\":\"LTokenIndexUpdated\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getLTokenInterestIndex(DataStruct.ReserveData storage)\":{\"details\":\"Returns the ongoing normalized income for the reserve A value of 1e27 means there is no income. As time passes, the income is accrued A value of 2*1e27 means for each unit of asset one unit of income has been accrued\",\"params\":{\"reserve\":\"The reserve object\"},\"returns\":{\"_0\":\"the normalized income. expressed in ray*\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/logic/Index.sol\":\"Index\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/libraries/DataStruct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPY;\\n    uint256 depositAPY;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    AssetBondState state;\\n    address borrower;\\n    address signer;\\n    address collateralServiceProvider;\\n    uint256 principal;\\n    uint256 debtCeiling;\\n    uint256 couponRate;\\n    uint256 interestRate;\\n    uint256 delinquencyRate;\\n    uint256 loanStartTimestamp;\\n    uint256 collateralizeTimestamp;\\n    uint256 maturityTimestamp;\\n    uint256 liquidationTimestamp;\\n    string ipfsHash; // refactor : gas\\n    string signerOpinionHash;\\n  }\\n\\n  struct AssetBondIdData {\\n    uint256 nonce;\\n    uint256 countryCode;\\n    uint256 collateralServiceProviderIdentificationNumber;\\n    uint256 collateralLatitude;\\n    uint256 collateralLatitudeSign;\\n    uint256 collateralLongitude;\\n    uint256 collateralLongitudeSign;\\n    uint256 collateralDetail;\\n    uint256 collateralCategory;\\n    uint256 productNumber;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * DELINQUENT:\\n    * REDEEMED:\\n    * LIQUIDATED:\\n   */\\n  enum AssetBondState {\\n    EMPTY,\\n    SETTLED,\\n    CONFIRMED,\\n    COLLATERALIZED,\\n    DELINQUENT,\\n    REDEEMED,\\n    LIQUIDATED\\n  }\\n}\\n\",\"keccak256\":\"0xfef0408a202a6814e92f396333b81c78b4fff0bb1a9411b64afe849ced4ea3b1\",\"license\":\"MIT\"},\"contracts/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary Math {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant SECONDSPERYEAR = 365 days;\\n\\n  function calculateLinearInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\\n  }\\n\\n  /**\\n   * @notice Author : AAVE\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    // loss of precision is endurable\\n    // slither-disable-next-line divide-before-multiply\\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  function calculateRateInIncreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountIn,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\\n\\n    uint256 newTotalBalance = totalBalance + amountIn;\\n    uint256 newAverageRate = (weightedAverageRate + weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n\\n  function calculateRateInDecreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountOut,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    // if decreasing amount exceeds totalBalance,\\n    // overall rate and balacne would be set 0\\n    if (totalBalance <= amountOut) {\\n      return (0, 0);\\n    }\\n\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\\n\\n    if (weightedAverageRate <= weightedAmountRate) {\\n      return (0, 0);\\n    }\\n\\n    uint256 newTotalBalance = totalBalance - amountOut;\\n\\n    uint256 newAverageRate = (weightedAverageRate - weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n}\\n\",\"keccak256\":\"0x8b72d69b39c8f545155657e365f56dc019a35cd65aecc49f039a99a27329e3d5\",\"license\":\"MIT\"},\"contracts/libraries/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x219da6a5d0c7c597faad6e638a2f0174b75d2ae50ee97314fb4afbc244abf01f\",\"license\":\"MIT\"},\"contracts/logic/Index.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '../libraries/DataStruct.sol';\\nimport '../libraries/Math.sol';\\n\\nlibrary Index {\\n  using WadRayMath for uint256;\\n  using Index for DataStruct.ReserveData;\\n\\n  event LTokenIndexUpdated(address indexed asset, uint256 lTokenIndex, uint256 lastUpdateTimestamp);\\n\\n  /**\\n   * @dev Returns the ongoing normalized income for the reserve\\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\n   * @param reserve The reserve object\\n   * @return the normalized income. expressed in ray\\n   **/\\n  function getLTokenInterestIndex(DataStruct.ReserveData storage reserve)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    uint256 lastUpdateTimestamp = reserve.lastUpdateTimestamp;\\n\\n    // strict equality is not dangerous here\\n    // divide-before-multiply dangerous-strict-equalities\\n    if (lastUpdateTimestamp == block.timestamp) {\\n      return reserve.lTokenInterestIndex;\\n    }\\n\\n    uint256 newIndex = Math\\n    .calculateLinearInterest(reserve.depositAPY, lastUpdateTimestamp, block.timestamp)\\n    .rayMul(reserve.lTokenInterestIndex);\\n\\n    return newIndex;\\n  }\\n\\n  /**\\n   * @dev Updates the reserve indexes and the timestamp\\n   * @param reserve The reserve to be updated\\n   **/\\n  function updateState(DataStruct.ReserveData storage reserve, address asset) internal {\\n    if (reserve.depositAPY == 0) {\\n      reserve.lastUpdateTimestamp = block.timestamp;\\n      return;\\n    }\\n\\n    reserve.lTokenInterestIndex = getLTokenInterestIndex(reserve);\\n    reserve.lastUpdateTimestamp = block.timestamp;\\n\\n    emit LTokenIndexUpdated(asset, reserve.lTokenInterestIndex, reserve.lastUpdateTimestamp);\\n  }\\n}\\n\",\"keccak256\":\"0x5d04bd1c3136ea9dab619fb8dc964f8ee8da7dcc049e1c7b702f70d98fd40a7c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61021561003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c80635ed891411461003a575b600080fd5b61004d610048366004610143565b61005f565b60405190815260200160405180910390f35b60048101546000904281141561007b575050600181015461009f565b600061009a8460010154610094866003015485426100a4565b906100eb565b925050505b919050565b6000806100b184846101b2565b9050676765c793fa10079d601b1b6301e133806100ce8388610193565b6100d89190610173565b6100e2919061015b565b95945050505050565b60008215806100f8575081155b156101055750600061013d565b676765c793fa10079d601b1b61011c600282610173565b6101268486610193565b610130919061015b565b61013a9190610173565b90505b92915050565b600060208284031215610154578081fd5b5035919050565b6000821982111561016e5761016e6101c9565b500190565b60008261018e57634e487b7160e01b81526012600452602481fd5b500490565b60008160001904831182151516156101ad576101ad6101c9565b500290565b6000828210156101c4576101c46101c9565b500390565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220ea48d4fd47f8ec83d9c2087b4871fd6019743e11df320a6bba2db50dddee1b4264736f6c63430008030033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c80635ed891411461003a575b600080fd5b61004d610048366004610143565b61005f565b60405190815260200160405180910390f35b60048101546000904281141561007b575050600181015461009f565b600061009a8460010154610094866003015485426100a4565b906100eb565b925050505b919050565b6000806100b184846101b2565b9050676765c793fa10079d601b1b6301e133806100ce8388610193565b6100d89190610173565b6100e2919061015b565b95945050505050565b60008215806100f8575081155b156101055750600061013d565b676765c793fa10079d601b1b61011c600282610173565b6101268486610193565b610130919061015b565b61013a9190610173565b90505b92915050565b600060208284031215610154578081fd5b5035919050565b6000821982111561016e5761016e6101c9565b500190565b60008261018e57634e487b7160e01b81526012600452602481fd5b500490565b60008160001904831182151516156101ad576101ad6101c9565b500290565b6000828210156101c4576101c46101c9565b500390565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220ea48d4fd47f8ec83d9c2087b4871fd6019743e11df320a6bba2db50dddee1b4264736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getLTokenInterestIndex(DataStruct.ReserveData storage)": {
        "details": "Returns the ongoing normalized income for the reserve A value of 1e27 means there is no income. As time passes, the income is accrued A value of 2*1e27 means for each unit of asset one unit of income has been accrued",
        "params": {
          "reserve": "The reserve object"
        },
        "returns": {
          "_0": "the normalized income. expressed in ray*"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}