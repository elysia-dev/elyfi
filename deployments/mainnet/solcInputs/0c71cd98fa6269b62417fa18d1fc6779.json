{
  "language": "Solidity",
  "sources": {
    "contracts/Connector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport './libraries/Role.sol';\n\nimport './interfaces/IConnector.sol';\n\nimport './ConnectorStorage.sol';\n\n/**\n * @title ELYFI Connector\n * @author ELYSIA\n * @notice ELYFI functions through continual interaction among the various participants.\n * In order to link the real assets and the blockchain, unlike the existing DeFi platform,\n * ELYFI has a group of participants in charge of actual legal contracts and maintenance.\n * 1. Collateral service providers are a group of users who sign a collateral contract with\n * a borrower who takes out a real asset-backed loan and borrows cryptocurrencies from the\n * Money Pool based on this contract.\n * 2. The council, such as legal service provider is a corporation that provides\n * legal services such as document review in the context of legal proceedings, consulting,\n * and the provision of documents necessary in the process of taking out loans secured by real assets,\n * In the future, the types of participant groups will be diversified and subdivided.\n * @dev Only admin can add or revoke roles of the ELYFI. The admin account of the connector is strictly\n * managed, and it is to be managed by governance of ELYFI.\n */\ncontract Connector is IConnector, ConnectorStorage, Ownable {\n  constructor() {}\n\n  function addCouncil(address account) external onlyOwner {\n    _grantRole(Role.COUNCIL, account);\n    emit NewCouncilAdded(account);\n  }\n\n  function addCollateralServiceProvider(address account) external onlyOwner {\n    _grantRole(Role.CollateralServiceProvider, account);\n    emit NewCollateralServiceProviderAdded(account);\n  }\n\n  function revokeCouncil(address account) external onlyOwner {\n    _revokeRole(Role.COUNCIL, account);\n    emit CouncilRevoked(account);\n  }\n\n  function revokeCollateralServiceProvider(address account) external onlyOwner {\n    _revokeRole(Role.CollateralServiceProvider, account);\n    emit CollateralServiceProviderRevoked(account);\n  }\n\n  function _grantRole(bytes32 role, address account) internal {\n    _roles[role].participants[account] = true;\n  }\n\n  function _revokeRole(bytes32 role, address account) internal {\n    _roles[role].participants[account] = false;\n  }\n\n  function _hasRole(bytes32 role, address account) internal view returns (bool) {\n    return _roles[role].participants[account];\n  }\n\n  function isCollateralServiceProvider(address account) external view override returns (bool) {\n    return _hasRole(Role.CollateralServiceProvider, account);\n  }\n\n  function isCouncil(address account) external view override returns (bool) {\n    return _hasRole(Role.COUNCIL, account);\n  }\n\n  function isMoneyPoolAdmin(address account) external view override returns (bool) {\n    return owner() == account;\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/libraries/Role.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n * @title ELYFI Role\n * @author ELYSIA\n */\nlibrary Role {\n  bytes32 internal constant CollateralServiceProvider = 'CollateralServiceProvider';\n  bytes32 internal constant COUNCIL = 'COUNCIL';\n  bytes32 internal constant MONEYPOOL_ADMIN = 'MONEYPOOL_ADMIN';\n}\n"
    },
    "contracts/interfaces/IConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IConnector {\n  /**\n   * @notice Emitted when an admin adds a council role\n   **/\n  event NewCouncilAdded(address indexed account);\n\n  /**\n   * @notice Emitted when an admin adds a collateral service provider role\n   **/\n  event NewCollateralServiceProviderAdded(address indexed account);\n\n  /**\n   * @notice Emitted when a council role is revoked by admin\n   **/\n  event CouncilRevoked(address indexed account);\n\n  /**\n   * @notice Emitted when a collateral service provider role is revoked by admin\n   **/\n  event CollateralServiceProviderRevoked(address indexed account);\n\n  function isCollateralServiceProvider(address account) external view returns (bool);\n\n  function isCouncil(address account) external view returns (bool);\n\n  function isMoneyPoolAdmin(address account) external view returns (bool);\n}\n"
    },
    "contracts/ConnectorStorage.sol": {
      "content": "import './interfaces/IMoneyPool.sol';\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n * @title ELYFI Connector storage\n * @author ELYSIA\n */\ncontract ConnectorStorage {\n  struct RoleData {\n    mapping(address => bool) participants;\n    bytes32 admin;\n  }\n\n  mapping(bytes32 => RoleData) internal _roles;\n\n  IMoneyPool internal _moneyPool;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/DataStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nlibrary DataStruct {\n  /**\n    @notice The main reserve data struct.\n   */\n  struct ReserveData {\n    uint256 moneyPoolFactor;\n    uint256 lTokenInterestIndex;\n    uint256 borrowAPY;\n    uint256 depositAPY;\n    uint256 lastUpdateTimestamp;\n    address lTokenAddress;\n    address dTokenAddress;\n    address interestModelAddress;\n    address tokenizerAddress;\n    uint8 id;\n    bool isPaused;\n    bool isActivated;\n  }\n\n  /**\n   * @notice The asset bond data struct.\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\n   * between Collateral Service Provider and lender.\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\n   * @param borrower The address of the borrower.\n   */\n  struct AssetBondData {\n    AssetBondState state;\n    address borrower;\n    address signer;\n    address collateralServiceProvider;\n    uint256 principal;\n    uint256 debtCeiling;\n    uint256 couponRate;\n    uint256 interestRate;\n    uint256 delinquencyRate;\n    uint256 loanStartTimestamp;\n    uint256 collateralizeTimestamp;\n    uint256 maturityTimestamp;\n    uint256 liquidationTimestamp;\n    string ipfsHash; // refactor : gas\n    string signerOpinionHash;\n  }\n\n  struct AssetBondIdData {\n    uint256 nonce;\n    uint256 countryCode;\n    uint256 collateralServiceProviderIdentificationNumber;\n    uint256 collateralLatitude;\n    uint256 collateralLatitudeSign;\n    uint256 collateralLongitude;\n    uint256 collateralLongitudeSign;\n    uint256 collateralDetail;\n    uint256 collateralCategory;\n    uint256 productNumber;\n  }\n\n  /**\n    @notice The states of asset bond\n    * EMPTY: After\n    * SETTLED:\n    * CONFIRMED:\n    * COLLATERALIZED:\n    * DELINQUENT:\n    * REDEEMED:\n    * LIQUIDATED:\n   */\n  enum AssetBondState {\n    EMPTY,\n    SETTLED,\n    CONFIRMED,\n    COLLATERALIZED,\n    DELINQUENT,\n    REDEEMED,\n    LIQUIDATED\n  }\n}\n"
    },
    "contracts/interfaces/IMoneyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IMoneyPool {\n  event NewReserve(\n    address indexed asset,\n    address lToken,\n    address dToken,\n    address interestModel,\n    address tokenizer,\n    address incentivePool,\n    uint256 moneyPoolFactor\n  );\n\n  event Deposit(address indexed asset, address indexed account, uint256 amount);\n\n  event Withdraw(\n    address indexed asset,\n    address indexed account,\n    address indexed to,\n    uint256 amount\n  );\n\n  event Borrow(\n    address indexed asset,\n    address indexed collateralServiceProvider,\n    address indexed borrower,\n    uint256 tokenId,\n    uint256 borrowAPY,\n    uint256 borrowAmount\n  );\n\n  event Repay(\n    address indexed asset,\n    address indexed borrower,\n    uint256 tokenId,\n    uint256 userDTokenBalance,\n    uint256 feeOnCollateralServiceProvider\n  );\n\n  event Liquidation(\n    address indexed asset,\n    address indexed borrower,\n    uint256 tokenId,\n    uint256 userDTokenBalance,\n    uint256 feeOnCollateralServiceProvider\n  );\n\n  function deposit(\n    address asset,\n    address account,\n    uint256 amount\n  ) external;\n\n  function withdraw(\n    address asset,\n    address account,\n    uint256 amount\n  ) external;\n\n  function borrow(address asset, uint256 tokenID) external;\n\n  function repay(address asset, uint256 tokenId) external;\n\n  function liquidate(address asset, uint256 tokenId) external;\n\n  function getLTokenInterestIndex(address asset) external view returns (uint256);\n\n  function getReserveData(address asset) external view returns (DataStruct.ReserveData memory);\n\n  function addNewReserve(\n    address asset,\n    address lToken,\n    address dToken,\n    address interestModel,\n    address tokenizer,\n    address incentivePool,\n    uint256 moneyPoolFactor_\n  ) external;\n}\n"
    },
    "contracts/TokenizerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport './libraries/DataStruct.sol';\n\nimport './logic/Index.sol';\n\nimport './interfaces/IConnector.sol';\nimport './interfaces/IMoneyPool.sol';\n\ncontract TokenizerStorage {\n  using Index for DataStruct.ReserveData;\n\n  IConnector internal _connector;\n\n  IMoneyPool internal _moneyPool;\n\n  mapping(uint256 => bytes32) internal _tokenType;\n\n  mapping(uint256 => address) internal _minter;\n\n  address internal _underlyingAsset;\n\n  // A mapping from an asset bond's identifier to the asset bond data struct.\n  // The token id is a unique identifier for asset bond.\n  mapping(uint256 => DataStruct.AssetBondData) internal _assetBondData;\n}\n"
    },
    "contracts/logic/Index.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Math.sol';\n\nlibrary Index {\n  using WadRayMath for uint256;\n  using Index for DataStruct.ReserveData;\n\n  event LTokenIndexUpdated(address indexed asset, uint256 lTokenIndex, uint256 lastUpdateTimestamp);\n\n  /**\n   * @dev Returns the ongoing normalized income for the reserve\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n   * @param reserve The reserve object\n   * @return the normalized income. expressed in ray\n   **/\n  function getLTokenInterestIndex(DataStruct.ReserveData storage reserve)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    // strict equality is not dangerous here\n    // divide-before-multiply dangerous-strict-equalities\n    if (lastUpdateTimestamp == block.timestamp) {\n      return reserve.lTokenInterestIndex;\n    }\n\n    uint256 newIndex = Math\n    .calculateLinearInterest(reserve.depositAPY, lastUpdateTimestamp, block.timestamp)\n    .rayMul(reserve.lTokenInterestIndex);\n\n    return newIndex;\n  }\n\n  /**\n   * @dev Updates the reserve indexes and the timestamp\n   * @param reserve The reserve to be updated\n   **/\n  function updateState(DataStruct.ReserveData storage reserve, address asset) internal {\n    if (reserve.depositAPY == 0) {\n      reserve.lastUpdateTimestamp = block.timestamp;\n      return;\n    }\n\n    reserve.lTokenInterestIndex = getLTokenInterestIndex(reserve);\n    reserve.lastUpdateTimestamp = block.timestamp;\n\n    emit LTokenIndexUpdated(asset, reserve.lTokenInterestIndex, reserve.lastUpdateTimestamp);\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport './WadRayMath.sol';\n\nlibrary Math {\n  using WadRayMath for uint256;\n\n  uint256 internal constant SECONDSPERYEAR = 365 days;\n\n  function calculateLinearInterest(\n    uint256 rate,\n    uint256 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\n  }\n\n  /**\n   * @notice Author : AAVE\n   * @dev Function to calculate the interest using a compounded interest rate formula\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n   *\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n   *\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate compounded during the timeDelta, in ray\n   **/\n  function calculateCompoundedInterest(\n    uint256 rate,\n    uint256 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\n\n    if (exp == 0) {\n      return WadRayMath.ray();\n    }\n\n    uint256 expMinusOne = exp - 1;\n\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n    // loss of precision is endurable\n    // slither-disable-next-line divide-before-multiply\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\n\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\n  }\n\n  function calculateRateInIncreasingBalance(\n    uint256 averageRate,\n    uint256 totalBalance,\n    uint256 amountIn,\n    uint256 rate\n  ) internal pure returns (uint256, uint256) {\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\n\n    uint256 newTotalBalance = totalBalance + amountIn;\n    uint256 newAverageRate = (weightedAverageRate + weightedAmountRate).rayDiv(\n      newTotalBalance.wadToRay()\n    );\n\n    return (newTotalBalance, newAverageRate);\n  }\n\n  function calculateRateInDecreasingBalance(\n    uint256 averageRate,\n    uint256 totalBalance,\n    uint256 amountOut,\n    uint256 rate\n  ) internal pure returns (uint256, uint256) {\n    // if decreasing amount exceeds totalBalance,\n    // overall rate and balacne would be set 0\n    if (totalBalance <= amountOut) {\n      return (0, 0);\n    }\n\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\n\n    if (weightedAverageRate <= weightedAmountRate) {\n      return (0, 0);\n    }\n\n    uint256 newTotalBalance = totalBalance - amountOut;\n\n    uint256 newAverageRate = (weightedAverageRate - weightedAmountRate).rayDiv(\n      newTotalBalance.wadToRay()\n    );\n\n    return (newTotalBalance, newAverageRate);\n  }\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant halfWAD = WAD / 2;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @return One ray, 1e27\n   **/\n  function ray() internal pure returns (uint256) {\n    return RAY;\n  }\n\n  /**\n   * @return One wad, 1e18\n   **/\n\n  function wad() internal pure returns (uint256) {\n    return WAD;\n  }\n\n  /**\n   * @return Half ray, 1e27/2\n   **/\n  function halfRay() internal pure returns (uint256) {\n    return halfRAY;\n  }\n\n  /**\n   * @return Half ray, 1e18/2\n   **/\n  function halfWad() internal pure returns (uint256) {\n    return halfWAD;\n  }\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a*b, in wad\n   **/\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    return (a * b + halfWAD) / WAD;\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a/b, in wad\n   **/\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, 'Division by Zero');\n    uint256 halfB = b / 2;\n    return (a * WAD + halfB) / b;\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a*b, in ray\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    return (a * b + halfRAY) / RAY;\n  }\n\n  /**\n   * @dev Divides two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a/b, in ray\n   **/\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, 'Division by Zero');\n    uint256 halfB = b / 2;\n    return (a * RAY + halfB) / b;\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @param a Ray\n   * @return a casted to wad, rounded half up to the nearest wad\n   **/\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\n    uint256 result = halfRatio + a;\n    return result / WAD_RAY_RATIO;\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @param a Wad\n   * @return a converted in ray\n   **/\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    uint256 result = a * WAD_RAY_RATIO;\n    return result;\n  }\n}\n"
    },
    "contracts/Tokenizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\n\nimport './libraries/WadRayMath.sol';\nimport './libraries/DataStruct.sol';\nimport './libraries/Math.sol';\nimport './libraries/Role.sol';\nimport './libraries/TimeConverter.sol';\n\nimport './logic/AssetBond.sol';\nimport './logic/Index.sol';\nimport './logic/Validation.sol';\n\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/ITokenizer.sol';\nimport './interfaces/IConnector.sol';\n\nimport './TokenizerStorage.sol';\n\n/**\n * @title ELYFI Tokenizer\n * @notice Asset bond token is a type of token that records information about real asset-backed bonds\n * and acts as bonds on-chain. It complies with the NFT standard, ERC721 and this token can be deposited\n * in the Money Pool to execute a loan contract.\n * @author ELYSIA\n */\ncontract Tokenizer is ITokenizer, TokenizerStorage, ERC721 {\n  using WadRayMath for uint256;\n  using AssetBond for DataStruct.AssetBondData;\n  using Validation for DataStruct.AssetBondData;\n  using Index for DataStruct.AssetBondData;\n\n  /************ Initialize Functions ************/\n\n  constructor(\n    address connector,\n    address moneyPool,\n    string memory name_,\n    string memory symbol_\n  ) ERC721(name_, symbol_) {\n    _connector = IConnector(connector);\n    _moneyPool = IMoneyPool(moneyPool);\n  }\n\n  /************ View Functions *************/\n\n  /**\n   * @notice Returns the state of the asset bond\n   * @dev The state of the asset bond is `LIQUIDATED` when the current timestamp is greater than\n   * liquidation timestamp.\n   * @param tokenId The asset bond tokenId\n   * @return The data struct of the asset bond\n   **/\n  function getAssetBondData(uint256 tokenId)\n    external\n    view\n    override\n    returns (DataStruct.AssetBondData memory)\n  {\n    DataStruct.AssetBondData memory assetBondData = _assetBondData[tokenId];\n    // assetBondData.state is enum\n    // divide-before-multiply dangerous-strict-equalities\n    if (\n      block.timestamp >= assetBondData.liquidationTimestamp &&\n      assetBondData.state == DataStruct.AssetBondState.COLLATERALIZED\n    ) {\n      assetBondData.state = DataStruct.AssetBondState.LIQUIDATED;\n    }\n\n    return assetBondData;\n  }\n\n  /**\n   * @notice When the borrower takes a loan, the repayment is the sum of two types of amounts:\n   * debt on the money pool and fee on the collateral service provider. The former is the amount to be\n   * repaid to the moneypool, and the latter is the amount to be paid to collateral service provider as a fee.\n   * @dev Returns the state debt of the asset bond\n   * @param tokenId The id of the asset bond\n   * @return Accrued debt on the moneypool and the fee on the collateral service provider.\n   **/\n  function getAssetBondDebtData(uint256 tokenId) external view override returns (uint256, uint256) {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n\n    return assetBond.getAssetBondDebtData();\n  }\n\n  function getMinter(uint256 tokenId) external view override returns (address) {\n    return _minter[tokenId];\n  }\n\n  function getAssetBondIdData(uint256 tokenId)\n    external\n    pure\n    override\n    returns (DataStruct.AssetBondIdData memory)\n  {\n    return AssetBond.parseAssetBondId(tokenId);\n  }\n\n  /************ AssetBond Formation Functions ************/\n\n  /**\n   * @notice This function can be called by collateral service providers when they want to sign a contract.\n   * Borrowers who wants to take out a loan backed by real asset must enter into a contract\n   * with a collateral service provider to obtain a loan. Borrowers should submit various documents necessary\n   * for evaluating a loan secured by real assets to the collateral service provider.\n   * @param account CollateralServiceProvider address\n   * @param tokenId Unique identifier for asset bond.\n   */\n  function mintAssetBond(address account, uint256 tokenId)\n    external\n    override\n    onlyCollateralServiceProvider\n  {\n    require(_connector.isCollateralServiceProvider(account), 'NotAllowedMinter');\n\n    // validate tokenId : tokenId should have information about\n\n    DataStruct.AssetBondIdData memory idData = AssetBond.parseAssetBondId(tokenId);\n\n    Validation.validateTokenId(idData);\n\n    // mint AssetBond to CollateralServiceProvider\n    _safeMint(account, tokenId);\n\n    _minter[tokenId] = msg.sender;\n\n    emit EmptyAssetBondMinted(account, tokenId);\n  }\n\n  struct SettleAssetBondLocalVars {\n    uint256 loanStartTimestamp;\n    uint256 maturityTimestamp;\n    uint256 liquidationTimestamp;\n  }\n\n  /**\n   * @notice This function is called after collateral service provider based on the documents submitted by the loan applicant,\n   * risk analysis for the relevant asset is conducted, and the loan availability, maximum loanable amount and the interest\n   * rate between collateral service provider and borrower are calculated.\n   * @param borrower The address of the borrower who must repay and retrieve the asset bond\n   * @param signer A third-party agency address that reviews entities listed on the asset bond data\n   * @param tokenId Token id to settle\n   * @param principal The borrow amount based on the contract between collateral service provider and borrower in reality\n   * @param couponRate The coupon rate of the bond\n   * @param delinquencyRate The overdue interest rate of the bond. After the loan duration, the borrower\n   * @param debtCeiling DebtCeiling, the available value of collateral asset when liquidated\n   * @param loanDuration LoanDuration\n   * @param loanStartTimeYear LoanStartTimeYear\n   * @param loanStartTimeMonth LoanStartTimeMonth\n   * @param loanStartTimeDay LoanStartTimeDay\n   * @param ipfsHash IpfsHash which contract and collateral data stored\n   The interest rate paid on a bond by its issuer for the term of the security\n   */\n  function settleAssetBond(\n    address borrower,\n    address signer,\n    uint256 tokenId,\n    uint256 principal,\n    uint256 couponRate,\n    uint256 delinquencyRate,\n    uint256 debtCeiling,\n    uint16 loanDuration,\n    uint16 loanStartTimeYear,\n    uint8 loanStartTimeMonth,\n    uint8 loanStartTimeDay,\n    string memory ipfsHash\n  ) external onlyCollateralServiceProvider {\n    SettleAssetBondLocalVars memory vars;\n    require(ownerOf(tokenId) == msg.sender, 'OnlyOnwerCanSettle');\n\n    require(_assetBondData[tokenId].state == DataStruct.AssetBondState.EMPTY, 'AlreadySettled');\n\n    require(_connector.isCouncil(signer), 'SignerIsNotCouncil');\n    vars.loanStartTimestamp = 0;\n    vars.maturityTimestamp = 0;\n    vars.liquidationTimestamp = 0;\n\n    vars.loanStartTimestamp = TimeConverter.toTimestamp(\n      loanStartTimeYear,\n      loanStartTimeMonth,\n      loanStartTimeDay\n    );\n    vars.maturityTimestamp = vars.loanStartTimestamp + (uint256(loanDuration) * 1 days);\n    vars.liquidationTimestamp = vars.maturityTimestamp + (10 * 1 days);\n\n    DataStruct.AssetBondData memory newAssetBond = DataStruct.AssetBondData({\n      state: DataStruct.AssetBondState.SETTLED,\n      borrower: borrower,\n      signer: signer,\n      collateralServiceProvider: msg.sender,\n      principal: principal,\n      debtCeiling: debtCeiling,\n      couponRate: couponRate,\n      interestRate: 0,\n      delinquencyRate: delinquencyRate,\n      loanStartTimestamp: vars.loanStartTimestamp,\n      collateralizeTimestamp: 0,\n      maturityTimestamp: vars.maturityTimestamp,\n      liquidationTimestamp: vars.liquidationTimestamp,\n      ipfsHash: ipfsHash,\n      signerOpinionHash: ''\n    });\n\n    Validation.validateSettleAssetBond(newAssetBond);\n\n    _assetBondData[tokenId] = newAssetBond;\n\n    emit AssetBondSettled(\n      borrower,\n      signer,\n      tokenId,\n      principal,\n      couponRate,\n      delinquencyRate,\n      debtCeiling,\n      vars.maturityTimestamp,\n      vars.liquidationTimestamp,\n      vars.loanStartTimestamp,\n      ipfsHash\n    );\n  }\n\n  /**\n   * @notice When the collateral service provider settled the informations based on the real world contract\n   * in asset bond token, the third party connector such as lawfrim should review this and sign it.\n   * The object for this process is to build trust in the token issuance in ELYFI.\n   * This final verification process is carried out by reliable parties such as lawfirm.\n   * The review is following four items.\n   * Determination of the authenticity of collateral security details entered in real estate registration\n   * Determination of the authenticity of the contract between a real estate owner and a collateral service provider\n   * Determination of the value of principal and interest through certificates of seal impressions\n   * of real estate owners and lenders\n   * Determination of whether the important information entered in smart contracts match the contract content\n   * This allows the asset bond tokens to be recognized as collateral on the blockchain.\n   * @param tokenId The token Id to release\n   * @param signerOpinionHash The signer can upload their opinion as a form of official documents on IPFS server.\n   */\n  function signAssetBond(uint256 tokenId, string memory signerOpinionHash) external onlyCouncil {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n    Validation.validateSignAssetBond(assetBond);\n\n    assetBond.state = DataStruct.AssetBondState.CONFIRMED;\n    assetBond.signerOpinionHash = signerOpinionHash;\n\n    emit AssetBondSigned(msg.sender, tokenId, signerOpinionHash);\n  }\n\n  /**\n   * @notice The collateral service provider can take out a loan of value equivalent to the collateral\n   * recored in asset bond tokens. The asset bond tokens are automatically transferred to the MoneyPool\n   * by internal function of `borrow` function.\n   * @dev The collateralizing asset bond token should be only from the MoneyPool.\n   * @param account The owner of asset bond token\n   * @param tokenId The token Id to collateralize\n   * @param borrowAmount The borrow amount.\n   * @param interestRate The interest rate of the loan between MoneyPool and borrower.\n   */\n  function collateralizeAssetBond(\n    address account,\n    uint256 tokenId,\n    uint256 borrowAmount,\n    uint256 interestRate\n  ) external override onlyMoneyPool {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n\n    assetBond.state = DataStruct.AssetBondState.COLLATERALIZED;\n\n    // set bond date data\n    assetBond.interestRate = interestRate;\n    assetBond.collateralizeTimestamp = block.timestamp;\n\n    transferFrom(account, address(_moneyPool), tokenId);\n\n    emit AssetBondCollateralized(account, tokenId, borrowAmount, interestRate);\n  }\n\n  /**\n   * @notice When the repayment scenario, the dTokens are destroyed and the collateral of the locked up\n   * asset bond tokens in the MoneyPool is unlocked. The asset bond tokens are transfered to the\n   * address of the borrower for terminating the collateral contract.\n   * @dev The releasing asset bond token should be only from the MoneyPool.\n   * @param account The borrower\n   * @param tokenId The token Id to release\n   */\n  function releaseAssetBond(address account, uint256 tokenId) external override onlyMoneyPool {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n    assetBond.state = DataStruct.AssetBondState.REDEEMED;\n\n    transferFrom(address(_moneyPool), account, tokenId);\n    emit AssetBondReleased(account, tokenId);\n  }\n\n  /**\n   * @notice When the liquidation scenario, the dTokens are destroyed and the collateral of the locked up\n   * asset bond tokens in the MoneyPool is transferred to liquidator.\n   * @dev The liquidating asset bond token should be only from the MoneyPool.\n   * @param account The liquidator\n   * @param tokenId The token Id to release\n   */\n  function liquidateAssetBond(address account, uint256 tokenId) external override onlyMoneyPool {\n    DataStruct.AssetBondData storage assetBond = _assetBondData[tokenId];\n    assetBond.state = DataStruct.AssetBondState.LIQUIDATED;\n    transferFrom(address(_moneyPool), account, tokenId);\n    emit AssetBondLiquidated(account, tokenId);\n  }\n\n  /************ Access Functions ************/\n\n  modifier onlyMoneyPool {\n    require(_msgSender() == address(_moneyPool), 'OnlyMoneyPool');\n    _;\n  }\n\n  modifier onlyCollateralServiceProvider {\n    require(_connector.isCollateralServiceProvider(msg.sender), 'OnlyCollateralServiceProvider');\n    _;\n  }\n\n  modifier onlyCouncil {\n    require(_connector.isCouncil(msg.sender), 'OnlyCouncil');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "contracts/libraries/TimeConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n * @title Ethereum timestamp conversion library\n * @author ethereum-datatime\n */\nlibrary TimeConverter {\n  struct DateTime {\n    uint16 year;\n    uint8 month;\n    uint8 day;\n    uint8 hour;\n    uint8 minute;\n    uint8 second;\n    uint8 weekday;\n  }\n\n  uint256 constant DAY_IN_SECONDS = 86400;\n  uint256 constant YEAR_IN_SECONDS = 31536000;\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n  uint256 constant HOUR_IN_SECONDS = 3600;\n  uint256 constant MINUTE_IN_SECONDS = 60;\n\n  uint16 constant ORIGIN_YEAR = 1970;\n\n  function isLeapYear(uint16 year) internal pure returns (bool) {\n    if (year % 4 != 0) {\n      return false;\n    }\n    if (year % 100 != 0) {\n      return true;\n    }\n    if (year % 400 != 0) {\n      return false;\n    }\n    return true;\n  }\n\n  function leapYearsBefore(uint256 year) internal pure returns (uint256) {\n    year -= 1;\n    return year / 4 - year / 100 + year / 400;\n  }\n\n  function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n    if (\n      month == 1 ||\n      month == 3 ||\n      month == 5 ||\n      month == 7 ||\n      month == 8 ||\n      month == 10 ||\n      month == 12\n    ) {\n      return 31;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n      return 30;\n    } else if (isLeapYear(year)) {\n      return 29;\n    } else {\n      return 28;\n    }\n  }\n\n  function parseTimestamp(uint256 timestamp) public pure returns (DateTime memory dateTime) {\n    uint256 secondsAccountedFor = 0;\n    uint256 buf;\n    uint8 i;\n\n    // Year\n    dateTime.year = getYear(timestamp);\n    buf = leapYearsBefore(dateTime.year) - leapYearsBefore(ORIGIN_YEAR);\n\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n    secondsAccountedFor += YEAR_IN_SECONDS * (dateTime.year - ORIGIN_YEAR - buf);\n\n    // Month\n    uint256 secondsInMonth;\n    for (i = 1; i <= 12; i++) {\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dateTime.year);\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\n        dateTime.month = i;\n        break;\n      }\n      secondsAccountedFor += secondsInMonth;\n    }\n\n    // Day\n    for (i = 1; i <= getDaysInMonth(dateTime.month, dateTime.year); i++) {\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n        dateTime.day = i;\n        break;\n      }\n      secondsAccountedFor += DAY_IN_SECONDS;\n    }\n\n    // Hour\n    dateTime.hour = getHour(timestamp);\n    // Minute\n    dateTime.minute = getMinute(timestamp);\n    // Second\n    dateTime.second = getSecond(timestamp);\n    // Day of week.\n    dateTime.weekday = getWeekday(timestamp);\n  }\n\n  function getYear(uint256 timestamp) internal pure returns (uint16) {\n    uint256 secondsAccountedFor = 0;\n    uint16 year;\n    uint256 numLeapYears;\n\n    // Year\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n    secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n    while (secondsAccountedFor > timestamp) {\n      if (isLeapYear(uint16(year - 1))) {\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n      } else {\n        secondsAccountedFor -= YEAR_IN_SECONDS;\n      }\n      year -= 1;\n    }\n    return year;\n  }\n\n  function getMonth(uint256 timestamp) internal pure returns (uint8) {\n    return parseTimestamp(timestamp).month;\n  }\n\n  function getDay(uint256 timestamp) internal pure returns (uint8) {\n    return parseTimestamp(timestamp).day;\n  }\n\n  function getHour(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / 60 / 60) % 24);\n  }\n\n  function getMinute(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / 60) % 60);\n  }\n\n  function getSecond(uint256 timestamp) internal pure returns (uint8) {\n    return uint8(timestamp % 60);\n  }\n\n  function getWeekday(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day\n  ) public pure returns (uint256 timestamp) {\n    return toTimestamp(year, month, day, 0, 0, 0);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day,\n    uint8 hour\n  ) public pure returns (uint256 timestamp) {\n    return toTimestamp(year, month, day, hour, 0, 0);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day,\n    uint8 hour,\n    uint8 minute,\n    uint8 second\n  ) public pure returns (uint256 timestamp) {\n    uint16 i;\n\n    // Year\n    for (i = ORIGIN_YEAR; i < year; i++) {\n      if (isLeapYear(i)) {\n        timestamp += LEAP_YEAR_IN_SECONDS;\n      } else {\n        timestamp += YEAR_IN_SECONDS;\n      }\n    }\n\n    // Month\n    uint8[12] memory monthDayCounts;\n    monthDayCounts[0] = 31;\n    if (isLeapYear(year)) {\n      monthDayCounts[1] = 29;\n    } else {\n      monthDayCounts[1] = 28;\n    }\n    monthDayCounts[2] = 31;\n    monthDayCounts[3] = 30;\n    monthDayCounts[4] = 31;\n    monthDayCounts[5] = 30;\n    monthDayCounts[6] = 31;\n    monthDayCounts[7] = 31;\n    monthDayCounts[8] = 30;\n    monthDayCounts[9] = 31;\n    monthDayCounts[10] = 30;\n    monthDayCounts[11] = 31;\n\n    for (i = 1; i < month; i++) {\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n    }\n\n    // Day\n    timestamp += DAY_IN_SECONDS * (day - 1);\n    // Hour\n    timestamp += HOUR_IN_SECONDS * (hour);\n    // Minute\n    timestamp += MINUTE_IN_SECONDS * (minute);\n    // Second\n    timestamp += second;\n\n    return timestamp;\n  }\n}\n"
    },
    "contracts/logic/AssetBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Math.sol';\nimport '../libraries/WadRayMath.sol';\nimport '../libraries/TimeConverter.sol';\n\nlibrary AssetBond {\n  using WadRayMath for uint256;\n  using AssetBond for DataStruct.AssetBondData;\n\n  uint256 constant NONCE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC00;\n  uint256 constant COUNTRY_CODE =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC003FF;\n  uint256 constant COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000003FFFFF;\n  uint256 constant COLLATERAL_LATITUDE =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000FFFFFFFFFFFFFFFFFF;\n  uint256 constant COLLATERAL_LATITUDE_SIGNS =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 constant COLLATERAL_LONGITUDE =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0000001FFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 constant COLLATERAL_LONGITUDE_SIGNS =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 constant COLLATERAL_DETAILS =\n    0xFFFFFFFFFFFFFFFFFFFFFC0000000003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 constant COLLATERAL_CATEGORY =\n    0xFFFFFFFFFFFFFFFFFFF003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 constant PRODUCT_NUMBER =\n    0xFFFFFFFFFFFFFFFFC00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  uint256 constant NONCE_START = 0;\n  uint256 constant COUNTRY_CODE_START = 10;\n  uint256 constant COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER_START = 22;\n  uint256 constant COLLATERAL_LATITUDE_START = 72;\n  uint256 constant COLLATERAL_LATITUDE_SIGNS_START = 100;\n  uint256 constant COLLATERAL_LONGITUDE_START = 101;\n  uint256 constant COLLATERAL_LONGITUDE_SIGNS_START = 129;\n  uint256 constant COLLATERAL_DETAILS_START = 130;\n  uint256 constant COLLATERAL_CATEGORY_START = 170;\n  uint256 constant PRODUCT_NUMBER_START = 180;\n\n  function parseAssetBondId(uint256 tokenId)\n    public\n    pure\n    returns (DataStruct.AssetBondIdData memory)\n  {\n    DataStruct.AssetBondIdData memory vars;\n    vars.nonce = tokenId & ~NONCE;\n    vars.countryCode = (tokenId & ~COUNTRY_CODE) >> COUNTRY_CODE_START;\n    vars.collateralServiceProviderIdentificationNumber =\n      (tokenId & ~COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER) >>\n      COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER_START;\n    vars.collateralLatitude = (tokenId & ~COLLATERAL_LATITUDE) >> COLLATERAL_LATITUDE_START;\n    vars.collateralLatitudeSign =\n      (tokenId & ~COLLATERAL_LATITUDE_SIGNS) >>\n      COLLATERAL_LATITUDE_SIGNS_START;\n    vars.collateralLongitude = (tokenId & ~COLLATERAL_LONGITUDE) >> COLLATERAL_LONGITUDE_START;\n    vars.collateralLongitudeSign =\n      (tokenId & ~COLLATERAL_LONGITUDE_SIGNS) >>\n      COLLATERAL_LONGITUDE_SIGNS_START;\n    vars.collateralDetail = (tokenId & ~COLLATERAL_DETAILS) >> COLLATERAL_DETAILS_START;\n    vars.collateralCategory = (tokenId & ~COLLATERAL_CATEGORY) >> COLLATERAL_CATEGORY_START;\n    vars.productNumber = (tokenId & ~PRODUCT_NUMBER) >> PRODUCT_NUMBER_START;\n\n    return vars;\n  }\n\n  function getAssetBondDebtData(DataStruct.AssetBondData memory assetBondData)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    if (assetBondData.state != DataStruct.AssetBondState.COLLATERALIZED) {\n      return (0, 0);\n    }\n\n    uint256 accruedDebtOnMoneyPool = Math\n    .calculateCompoundedInterest(\n      assetBondData.interestRate,\n      assetBondData.collateralizeTimestamp,\n      block.timestamp\n    ).rayMul(assetBondData.principal);\n\n    uint256 feeOnCollateralServiceProvider = calculateFeeOnRepayment(\n      assetBondData,\n      block.timestamp\n    );\n\n    return (accruedDebtOnMoneyPool, feeOnCollateralServiceProvider);\n  }\n\n  struct CalculateFeeOnRepaymentLocalVars {\n    TimeConverter.DateTime paymentDateTimeStruct;\n    uint256 paymentDate;\n    uint256 firstTermRate;\n    uint256 secondTermRate;\n    uint256 secondTermOverdueRate;\n    uint256 thirdTermRate;\n    uint256 totalRate;\n  }\n\n  function calculateFeeOnRepayment(\n    DataStruct.AssetBondData memory assetBondData,\n    uint256 paymentTimestamp\n  ) internal pure returns (uint256) {\n    CalculateFeeOnRepaymentLocalVars memory vars;\n\n    vars.firstTermRate = Math.calculateCompoundedInterest(\n      assetBondData.couponRate,\n      assetBondData.loanStartTimestamp,\n      assetBondData.collateralizeTimestamp\n    );\n\n    vars.paymentDateTimeStruct = TimeConverter.parseTimestamp(paymentTimestamp);\n    vars.paymentDate = TimeConverter.toTimestamp(\n      vars.paymentDateTimeStruct.year,\n      vars.paymentDateTimeStruct.month,\n      vars.paymentDateTimeStruct.day + 1\n    );\n\n    if (paymentTimestamp <= assetBondData.liquidationTimestamp) {\n      vars.secondTermRate =\n        Math.calculateCompoundedInterest(\n          assetBondData.couponRate - assetBondData.interestRate,\n          assetBondData.collateralizeTimestamp,\n          paymentTimestamp\n        ) -\n        WadRayMath.ray();\n      vars.thirdTermRate =\n        Math.calculateCompoundedInterest(\n          assetBondData.couponRate,\n          paymentTimestamp,\n          vars.paymentDate\n        ) -\n        WadRayMath.ray();\n\n      vars.totalRate = vars.firstTermRate + vars.secondTermRate + vars.thirdTermRate;\n\n      return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\n    }\n\n    vars.secondTermRate =\n      Math.calculateCompoundedInterest(\n        assetBondData.couponRate - assetBondData.interestRate,\n        assetBondData.collateralizeTimestamp,\n        assetBondData.maturityTimestamp\n      ) -\n      WadRayMath.ray();\n    vars.secondTermOverdueRate =\n      Math.calculateCompoundedInterest(\n        assetBondData.couponRate + assetBondData.delinquencyRate - assetBondData.interestRate,\n        assetBondData.maturityTimestamp,\n        paymentTimestamp\n      ) -\n      WadRayMath.ray();\n    vars.thirdTermRate =\n      Math.calculateCompoundedInterest(\n        assetBondData.couponRate + assetBondData.delinquencyRate,\n        paymentTimestamp,\n        vars.paymentDate\n      ) -\n      WadRayMath.ray();\n\n    vars.totalRate =\n      vars.firstTermRate +\n      vars.secondTermRate +\n      vars.secondTermOverdueRate +\n      vars.thirdTermRate;\n\n    return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\n  }\n\n  function getAssetBondLiquidationData(DataStruct.AssetBondData memory assetBondData)\n    internal\n    view\n    returns (uint256, uint256)\n  {\n    uint256 accruedDebtOnMoneyPool = Math\n    .calculateCompoundedInterest(\n      assetBondData.interestRate,\n      assetBondData.collateralizeTimestamp,\n      block.timestamp\n    ).rayMul(assetBondData.principal);\n\n    uint256 feeOnCollateralServiceProvider = calculateDebtAmountToLiquidation(\n      assetBondData,\n      block.timestamp\n    );\n\n    return (accruedDebtOnMoneyPool, feeOnCollateralServiceProvider);\n  }\n\n  struct CalculateDebtAmountToLiquidationLocalVars {\n    TimeConverter.DateTime paymentDateTimeStruct;\n    uint256 paymentDate;\n    uint256 firstTermRate;\n    uint256 secondTermRate;\n    uint256 totalRate;\n  }\n\n  function calculateDebtAmountToLiquidation(\n    DataStruct.AssetBondData memory assetBondData,\n    uint256 paymentTimestamp\n  ) internal pure returns (uint256) {\n    CalculateDebtAmountToLiquidationLocalVars memory vars;\n    vars.firstTermRate = Math.calculateCompoundedInterest(\n      assetBondData.couponRate,\n      assetBondData.loanStartTimestamp,\n      assetBondData.maturityTimestamp\n    );\n\n    vars.paymentDateTimeStruct = TimeConverter.parseTimestamp(paymentTimestamp);\n    vars.paymentDate = TimeConverter.toTimestamp(\n      vars.paymentDateTimeStruct.year,\n      vars.paymentDateTimeStruct.month,\n      vars.paymentDateTimeStruct.day + 1\n    );\n\n    vars.secondTermRate =\n      Math.calculateCompoundedInterest(\n        assetBondData.couponRate + assetBondData.delinquencyRate,\n        assetBondData.maturityTimestamp,\n        vars.paymentDate\n      ) -\n      WadRayMath.ray();\n    vars.totalRate = vars.firstTermRate + vars.secondTermRate;\n\n    return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\n  }\n}\n"
    },
    "contracts/logic/Validation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Math.sol';\n\nimport '../interfaces/ILToken.sol';\n\nlibrary Validation {\n  using WadRayMath for uint256;\n  using Validation for DataStruct.ReserveData;\n\n  /**\n   * @dev Validate Deposit\n   * Check reserve state\n   * @param reserve The reserve object\n   * @param amount Deposit amount\n   **/\n  function validateDeposit(DataStruct.ReserveData storage reserve, uint256 amount) public view {\n    require(amount != 0, 'InvalidAmount');\n    require(!reserve.isPaused, 'ReservePaused');\n    require(reserve.isActivated, 'ReserveInactivated');\n  }\n\n  /**\n   * @dev Validate Withdraw\n   * Check reserve state\n   * Check user amount\n   * Check user total debt(later)\n   * @param reserve The reserve object\n   * @param amount Withdraw amount\n   **/\n  function validateWithdraw(\n    DataStruct.ReserveData storage reserve,\n    address asset,\n    uint256 amount,\n    uint256 userLTokenBalance\n  ) public view {\n    require(amount != 0, 'InvalidAmount');\n    require(!reserve.isPaused, 'ReservePaused');\n    require(reserve.isActivated, 'ReserveInactivated');\n    require(amount <= userLTokenBalance, 'InsufficientBalance');\n    uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.lTokenAddress);\n    require(availableLiquidity >= amount, 'NotEnoughLiquidity');\n  }\n\n  function validateBorrow(\n    DataStruct.ReserveData storage reserve,\n    DataStruct.AssetBondData memory assetBond,\n    address asset,\n    uint256 borrowAmount\n  ) public view {\n    require(!reserve.isPaused, 'ReservePaused');\n    require(reserve.isActivated, 'ReserveInactivated');\n    require(assetBond.state == DataStruct.AssetBondState.CONFIRMED, 'OnlySignedTokenBorrowAllowed');\n    require(msg.sender == assetBond.collateralServiceProvider, 'OnlyOwnerBorrowAllowed');\n    uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.lTokenAddress);\n    require(availableLiquidity >= borrowAmount, 'NotEnoughLiquidity');\n    require(block.timestamp >= assetBond.loanStartTimestamp, 'NotTimeForLoanStart');\n    require(assetBond.loanStartTimestamp + 18 hours >= block.timestamp, 'TimeOutForCollateralize');\n  }\n\n  function validateLTokenTrasfer() internal pure {}\n\n  function validateRepay(\n    DataStruct.ReserveData storage reserve,\n    DataStruct.AssetBondData memory assetBond\n  ) public view {\n    require(reserve.isActivated, 'ReserveInactivated');\n    require(block.timestamp < assetBond.liquidationTimestamp, 'LoanExpired');\n    require(\n      (assetBond.state == DataStruct.AssetBondState.COLLATERALIZED ||\n        assetBond.state == DataStruct.AssetBondState.DELINQUENT),\n      'NotRepayableState'\n    );\n  }\n\n  function validateLiquidation(\n    DataStruct.ReserveData storage reserve,\n    DataStruct.AssetBondData memory assetBond\n  ) public view {\n    require(reserve.isActivated, 'ReserveInactivated');\n    require(assetBond.state == DataStruct.AssetBondState.LIQUIDATED, 'NotLiquidatbleState');\n  }\n\n  function validateSignAssetBond(DataStruct.AssetBondData storage assetBond) public view {\n    require(assetBond.state == DataStruct.AssetBondState.SETTLED, 'OnlySettledTokenSignAllowed');\n    require(assetBond.signer == msg.sender, 'NotAllowedSigner');\n  }\n\n  function validateSettleAssetBond(DataStruct.AssetBondData memory assetBond) public view {\n    require(block.timestamp < assetBond.loanStartTimestamp, 'OnlySettledSigned');\n    require(assetBond.loanStartTimestamp != assetBond.maturityTimestamp, 'LoanDurationInvalid');\n  }\n\n  function validateTokenId(DataStruct.AssetBondIdData memory idData) internal pure {\n    require(idData.collateralLatitude < 9000000, 'InvaildLatitude');\n    require(idData.collateralLongitude < 18000000, 'InvaildLongitude');\n  }\n}\n"
    },
    "contracts/interfaces/ITokenizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '../libraries/DataStruct.sol';\n\ninterface ITokenizer is IERC721 {\n  /**\n   * @notice Emitted when a collateral service provider mints an empty asset bond token.\n   * @param account The address of collateral service provider who minted\n   * @param tokenId The id of minted token\n   **/\n  event EmptyAssetBondMinted(address indexed account, uint256 tokenId);\n\n  /**\n   * @notice Emitted when a collateral service provider mints an empty asset bond token.\n   **/\n  event AssetBondSettled(\n    address indexed borrower,\n    address indexed signer,\n    uint256 tokenId,\n    uint256 principal,\n    uint256 couponRate,\n    uint256 delinquencyRate,\n    uint256 debtCeiling,\n    uint256 maturityTimestamp,\n    uint256 liquidationTimestamp,\n    uint256 loanStartTimestamp,\n    string ifpsHash\n  );\n\n  event AssetBondSigned(address indexed signer, uint256 tokenId, string signerOpinionHash);\n\n  event AssetBondCollateralized(\n    address indexed account,\n    uint256 tokenId,\n    uint256 borrowAmount,\n    uint256 interestRate\n  );\n\n  event AssetBondReleased(address indexed borrower, uint256 tokenId);\n\n  event AssetBondLiquidated(address indexed liquidator, uint256 tokenId);\n\n  function mintAssetBond(address account, uint256 id) external;\n\n  function collateralizeAssetBond(\n    address collateralServiceProvider,\n    uint256 tokenId,\n    uint256 borrowAmount,\n    uint256 borrowAPY\n  ) external;\n\n  function releaseAssetBond(address account, uint256 tokenId) external;\n\n  function liquidateAssetBond(address account, uint256 tokenId) external;\n\n  function getAssetBondIdData(uint256 tokenId)\n    external\n    view\n    returns (DataStruct.AssetBondIdData memory);\n\n  function getAssetBondData(uint256 tokenId)\n    external\n    view\n    returns (DataStruct.AssetBondData memory);\n\n  function getAssetBondDebtData(uint256 tokenId) external view returns (uint256, uint256);\n\n  function getMinter(uint256 tokenId) external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface ILToken is IERC20 {\n  /**\n   * @dev Emitted after lTokens are minted\n   * @param account The receiver of minted lToken\n   * @param amount The amount being minted\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed account, uint256 amount, uint256 index);\n\n  /**\n   * @dev Emitted after lTokens are burned\n   * @param account The owner of the lTokens, getting them burned\n   * @param underlyingAssetReceiver The address that will receive the underlying asset\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(\n    address indexed account,\n    address indexed underlyingAssetReceiver,\n    uint256 amount,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param account The account whose tokens are being transferred\n   * @param to The recipient\n   * @param amount The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed account, address indexed to, uint256 amount, uint256 index);\n\n  function mint(\n    address account,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Burns lTokens account `account` and sends the equivalent amount of underlying to `receiver`\n   * @param account The owner of the lTokens, getting them burned\n   * @param receiver The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Returns the address of the underlying asset of this LTokens (E.g. WETH for aWETH)\n   **/\n  function getUnderlyingAsset() external view returns (address);\n\n  function implicitBalanceOf(address account) external view returns (uint256);\n\n  function implicitTotalSupply() external view returns (uint256);\n\n  function transferUnderlyingTo(address underlyingAssetReceiver, uint256 amount) external;\n\n  function updateIncentivePool(address newIncentivePool) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/MoneyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport './libraries/DataStruct.sol';\n\nimport './logic/Index.sol';\nimport './logic/Rate.sol';\nimport './logic/Validation.sol';\nimport './logic/AssetBond.sol';\n\nimport './interfaces/ILToken.sol';\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/IIncentivePool.sol';\nimport './interfaces/ITokenizer.sol';\n\nimport './MoneyPoolStorage.sol';\n\n/**\n * @title Main contract for ELYFI version 1.\n * @author ELYSIA\n * @notice This is the first version of ELYFI. ELYFI has various contract interactions centered\n * on the Money Pool Contract. Several tokens are issued or destroyed to indicate the status of\n * participants, and all issuance and burn processes are carried out through the Money Pool Contract.\n * The depositor and borrower should approve the ELYFI moneypool contract to move their AssetBond token\n * or ERC20 tokens on their behalf.\n * @dev Only admin can modify the variables and state of the moneypool\n **/\ncontract MoneyPool is IMoneyPool, MoneyPoolStorage {\n  using SafeERC20 for IERC20;\n  using Index for DataStruct.ReserveData;\n  using Validation for DataStruct.ReserveData;\n  using Rate for DataStruct.ReserveData;\n  using AssetBond for DataStruct.AssetBondData;\n\n  constructor(uint256 maxReserveCount_, address connector) {\n    _connector = IConnector(connector);\n    _maxReserveCount = maxReserveCount_;\n    _reserveCount += 1;\n  }\n\n  /************ MoneyPool Deposit Functions ************/\n\n  /**\n   * @notice By depositing virtual assets in the MoneyPool and supply liquidity, depositors can receive\n   * interest accruing from the MoneyPool.The return on the deposit arises from the interest on real asset\n   * backed loans. MoneyPool depositors who deposit certain cryptoassets receives LTokens equivalent to\n   * the deposit amount. LTokens are backed by cryptoassets deposited in the MoneyPool in a 1:1 ratio.\n   * @dev Deposits an amount of underlying asset and receive corresponding LTokens.\n   * @param asset The address of the underlying asset to deposit\n   * @param account The address that will receive the LToken\n   * @param amount Deposit amount\n   **/\n  function deposit(\n    address asset,\n    address account,\n    uint256 amount\n  ) external override {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n\n    Validation.validateDeposit(reserve, amount);\n\n    reserve.updateState(asset);\n\n    reserve.updateRates(asset, amount, 0);\n\n    IERC20(asset).safeTransferFrom(msg.sender, reserve.lTokenAddress, amount);\n\n    ILToken(reserve.lTokenAddress).mint(account, amount, reserve.lTokenInterestIndex);\n\n    emit Deposit(asset, account, amount);\n  }\n\n  /**\n   * @notice The depositors can seize their virtual assets deposited in the MoneyPool whenever they wish.\n   * @dev Withdraws an amount of underlying asset from the reserve and burns the corresponding lTokens.\n   * @param asset The address of the underlying asset to withdraw\n   * @param account The address that will receive the underlying asset\n   * @param amount Withdrawl amount\n   **/\n  function withdraw(\n    address asset,\n    address account,\n    uint256 amount\n  ) external override {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n\n    uint256 userLTokenBalance = ILToken(reserve.lTokenAddress).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = amount;\n\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userLTokenBalance;\n    }\n\n    Validation.validateWithdraw(reserve, asset, amountToWithdraw, userLTokenBalance);\n\n    reserve.updateState(asset);\n\n    reserve.updateRates(asset, 0, amountToWithdraw);\n\n    ILToken(reserve.lTokenAddress).burn(\n      msg.sender,\n      account,\n      amountToWithdraw,\n      reserve.lTokenInterestIndex\n    );\n\n    emit Withdraw(asset, msg.sender, account, amountToWithdraw);\n  }\n\n  /************ AssetBond Formation Functions ************/\n\n  /**\n   * @notice The collateral service provider can take out a loan of value equivalent to the principal\n   * recorded in the asset bond data. As asset bonds are deposited as collateral in the Money Pool\n   * and loans are made, financial services that link real assets and cryptoassets can be achieved.\n   * @dev Transfer asset bond from the collateral service provider to the moneypool and mint dTokens\n   *  corresponding to principal. After that, transfer the underlying asset\n   * @param asset The address of the underlying asset to withdraw\n   * @param tokenId The id of the token to collateralize\n   **/\n  function borrow(address asset, uint256 tokenId) external override {\n    require(_connector.isCollateralServiceProvider(msg.sender), 'OnlyCollateralServiceProvider');\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    DataStruct.AssetBondData memory assetBond = ITokenizer(reserve.tokenizerAddress)\n    .getAssetBondData(tokenId);\n\n    uint256 borrowAmount = assetBond.principal;\n    address receiver = assetBond.borrower;\n\n    Validation.validateBorrow(reserve, assetBond, asset, borrowAmount);\n\n    reserve.updateState(asset);\n\n    ITokenizer(reserve.tokenizerAddress).collateralizeAssetBond(\n      msg.sender,\n      tokenId,\n      borrowAmount,\n      reserve.borrowAPY\n    );\n\n    IDToken(reserve.dTokenAddress).mint(msg.sender, receiver, borrowAmount, reserve.borrowAPY);\n\n    reserve.updateRates(asset, 0, borrowAmount);\n\n    ILToken(reserve.lTokenAddress).transferUnderlyingTo(receiver, borrowAmount);\n\n    emit Borrow(asset, msg.sender, receiver, tokenId, reserve.borrowAPY, borrowAmount);\n  }\n\n  /**\n   * @notice repays an amount of underlying asset from the reserve and burns the corresponding lTokens.\n   * @dev Transfer total repayment of the underlying asset from msg.sender to the moneypool and\n   * burn the corresponding amount of dTokens. Then release the asset bond token which is locked\n   * in the moneypool and transfer it to the borrower. The total amount of transferred underlying asset\n   * is the sum of the fee on the collateral service provider and debt on the moneypool\n   * @param asset The address of the underlying asset to repay\n   * @param tokenId The id of the token to retrieve\n   **/\n  function repay(address asset, uint256 tokenId) external override {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    DataStruct.AssetBondData memory assetBond = ITokenizer(reserve.tokenizerAddress)\n    .getAssetBondData(tokenId);\n\n    Validation.validateRepay(reserve, assetBond);\n\n    (uint256 accruedDebtOnMoneyPool, uint256 feeOnCollateralServiceProvider) = assetBond\n    .getAssetBondDebtData();\n\n    uint256 totalRetrieveAmount = accruedDebtOnMoneyPool + feeOnCollateralServiceProvider;\n\n    reserve.updateState(asset);\n\n    IERC20(asset).safeTransferFrom(msg.sender, reserve.lTokenAddress, totalRetrieveAmount);\n\n    IDToken(reserve.dTokenAddress).burn(assetBond.borrower, accruedDebtOnMoneyPool);\n\n    reserve.updateRates(asset, totalRetrieveAmount, 0);\n\n    ITokenizer(reserve.tokenizerAddress).releaseAssetBond(assetBond.borrower, tokenId);\n\n    ILToken(reserve.lTokenAddress).mint(\n      assetBond.collateralServiceProvider,\n      feeOnCollateralServiceProvider,\n      reserve.lTokenInterestIndex\n    );\n\n    emit Repay(\n      asset,\n      assetBond.borrower,\n      tokenId,\n      accruedDebtOnMoneyPool,\n      feeOnCollateralServiceProvider\n    );\n  }\n\n  function liquidate(address asset, uint256 tokenId) external override {\n    require(_connector.isCollateralServiceProvider(msg.sender), 'OnlyCollateralServiceProvider');\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    DataStruct.AssetBondData memory assetBond = ITokenizer(reserve.tokenizerAddress)\n    .getAssetBondData(tokenId);\n\n    Validation.validateLiquidation(reserve, assetBond);\n\n    (uint256 accruedDebtOnMoneyPool, uint256 feeOnCollateralServiceProvider) = assetBond\n    .getAssetBondLiquidationData();\n\n    uint256 totalLiquidationAmount = accruedDebtOnMoneyPool + feeOnCollateralServiceProvider;\n\n    reserve.updateState(asset);\n\n    IDToken(reserve.dTokenAddress).burn(assetBond.borrower, accruedDebtOnMoneyPool);\n\n    reserve.updateRates(asset, totalLiquidationAmount, 0);\n\n    IERC20(asset).safeTransferFrom(msg.sender, reserve.lTokenAddress, totalLiquidationAmount);\n\n    ITokenizer(reserve.tokenizerAddress).liquidateAssetBond(msg.sender, tokenId);\n\n    ILToken(reserve.lTokenAddress).mint(\n      assetBond.collateralServiceProvider,\n      feeOnCollateralServiceProvider,\n      reserve.lTokenInterestIndex\n    );\n\n    emit Liquidation(\n      asset,\n      assetBond.borrower,\n      tokenId,\n      accruedDebtOnMoneyPool,\n      feeOnCollateralServiceProvider\n    );\n  }\n\n  /************ View Functions ************/\n\n  /**\n   * @notice LToken Index is an indicator of interest occurring and accrued to liquidity providers\n   * who have provided liquidity to the Money Pool. LToken Index is calculated every time user activities\n   * occur in the Money Pool, such as loans and repayments by Money Pool participants.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The LToken interest index of reserve\n   */\n  function getLTokenInterestIndex(address asset) external view override returns (uint256) {\n    return _reserves[asset].getLTokenInterestIndex();\n  }\n\n  /**\n   * @dev Returns the reserveData struct of underlying asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    override\n    returns (DataStruct.ReserveData memory)\n  {\n    return _reserves[asset];\n  }\n\n  /************ Configuration Functions ************/\n\n  function addNewReserve(\n    address asset,\n    address lToken,\n    address dToken,\n    address interestModel,\n    address tokenizer,\n    address incentivePool,\n    uint256 moneyPoolFactor_\n  ) external override onlyMoneyPoolAdmin {\n    DataStruct.ReserveData memory newReserveData = DataStruct.ReserveData({\n      moneyPoolFactor: moneyPoolFactor_,\n      lTokenInterestIndex: WadRayMath.ray(),\n      borrowAPY: 0,\n      depositAPY: 0,\n      lastUpdateTimestamp: block.timestamp,\n      lTokenAddress: lToken,\n      dTokenAddress: dToken,\n      interestModelAddress: interestModel,\n      tokenizerAddress: tokenizer,\n      id: 0,\n      isPaused: false,\n      isActivated: true\n    });\n\n    _reserves[asset] = newReserveData;\n    _addNewReserveToList(asset);\n\n    IIncentivePool(incentivePool).initializeIncentivePool(lToken);\n\n    emit NewReserve(\n      asset,\n      lToken,\n      dToken,\n      interestModel,\n      tokenizer,\n      incentivePool,\n      moneyPoolFactor_\n    );\n  }\n\n  function _addNewReserveToList(address asset) internal {\n    uint256 reserveCount = _reserveCount;\n\n    require(reserveCount < _maxReserveCount, 'MaxReserveCountExceeded');\n\n    require(_reserves[asset].id == 0, 'DigitalAssetAlreadyAdded');\n\n    _reserves[asset].id = uint8(reserveCount);\n    _reservesList[reserveCount] = asset;\n\n    _reserveCount = reserveCount + 1;\n  }\n\n  function deactivateMoneyPool(address asset) external onlyMoneyPoolAdmin {\n    _reserves[asset].isActivated = false;\n  }\n\n  function activateMoneyPool(address asset) external onlyMoneyPoolAdmin {\n    _reserves[asset].isActivated = true;\n  }\n\n  function pauseMoneyPool(address asset) external onlyMoneyPoolAdmin {\n    _reserves[asset].isPaused = true;\n  }\n\n  function unPauseMoneyPool(address asset) external onlyMoneyPoolAdmin {\n    _reserves[asset].isPaused = false;\n  }\n\n  function updateIncentivePool(address asset, address newIncentivePool)\n    external\n    onlyMoneyPoolAdmin\n  {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n    ILToken(reserve.lTokenAddress).updateIncentivePool(newIncentivePool);\n  }\n\n  modifier onlyMoneyPoolAdmin {\n    require(_connector.isMoneyPoolAdmin(msg.sender), 'OnlyMoneyPoolAdmin');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/logic/Rate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\nimport '../libraries/Math.sol';\n\nimport '../interfaces/ILToken.sol';\nimport '../interfaces/IDToken.sol';\nimport '../interfaces/ITokenizer.sol';\nimport '../interfaces/IInterestRateModel.sol';\n\nlibrary Rate {\n  using WadRayMath for uint256;\n  using Rate for DataStruct.ReserveData;\n\n  event RatesUpdated(\n    address indexed underlyingAssetAddress,\n    uint256 lTokenIndex,\n    uint256 borrowAPY,\n    uint256 depositAPY,\n    uint256 totalBorrow,\n    uint256 totalDeposit\n  );\n\n  struct UpdateRatesLocalVars {\n    uint256 totalDToken;\n    uint256 newBorrowAPY;\n    uint256 newDepositAPY;\n    uint256 averageBorrowAPY;\n    uint256 totalVariableDebt;\n  }\n\n  function updateRates(\n    DataStruct.ReserveData storage reserve,\n    address underlyingAssetAddress,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) public {\n    UpdateRatesLocalVars memory vars;\n\n    vars.totalDToken = IDToken(reserve.dTokenAddress).totalSupply();\n\n    vars.averageBorrowAPY = IDToken(reserve.dTokenAddress).getTotalAverageRealAssetBorrowRate();\n\n    uint256 lTokenAssetBalance = IERC20(underlyingAssetAddress).balanceOf(reserve.lTokenAddress);\n    (vars.newBorrowAPY, vars.newDepositAPY) = IInterestRateModel(reserve.interestModelAddress)\n    .calculateRates(\n      lTokenAssetBalance,\n      vars.totalDToken,\n      depositAmount,\n      borrowAmount,\n      reserve.moneyPoolFactor\n    );\n\n    reserve.borrowAPY = vars.newBorrowAPY;\n    reserve.depositAPY = vars.newDepositAPY;\n\n    emit RatesUpdated(\n      underlyingAssetAddress,\n      reserve.lTokenInterestIndex,\n      vars.newBorrowAPY,\n      vars.newDepositAPY,\n      vars.totalDToken,\n      lTokenAssetBalance + depositAmount - borrowAmount + vars.totalDToken\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\ninterface IDToken is IERC20Metadata {\n  /**\n   * @dev Emitted when new stable debt is minted\n   * @param account The address of the account who triggered the minting\n   * @param receiver The recipient of stable debt tokens\n   * @param amount The amount minted\n   * @param currentBalance The current balance of the account\n   * @param balanceIncrease The increase in balance since the last action of the account\n   * @param newRate The rate of the debt after the minting\n   * @param avgStableRate The new average stable rate after the minting\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Mint(\n    address indexed account,\n    address indexed receiver,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 newRate,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Emitted when new stable debt is burned\n   * @param account The address of the account\n   * @param amount The amount being burned\n   * @param currentBalance The current balance of the account\n   * @param balanceIncrease The the increase in balance since the last action of the account\n   * @param avgStableRate The new average stable rate after the burning\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Burn(\n    address indexed account,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Mints debt token to the `receiver` address.\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `receiver` otherwise\n   * @param receiver The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 rate\n  ) external;\n\n  /**\n   * @dev Burns debt of `account`\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param account The address of the account getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address account, uint256 amount) external;\n\n  /**\n   * @dev Returns the average rate of all the stable rate loans.\n   * @return The average stable rate\n   **/\n  function getTotalAverageRealAssetBorrowRate() external view returns (uint256);\n\n  /**\n   * @dev Returns the stable rate of the account debt\n   * @return The stable rate of the account\n   **/\n  function getUserAverageRealAssetBorrowRate(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the timestamp of the last update of the account\n   * @return The timestamp\n   **/\n  function getUserLastUpdateTimestamp(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the principal, the total supply and the average stable rate\n   **/\n  function getDTokenData()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /**\n   * @dev Returns the timestamp of the last update of the total supply\n   * @return The timestamp\n   **/\n  function getTotalSupplyLastUpdated() external view returns (uint256);\n\n  /**\n   * @dev Returns the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the principal debt balance of the account\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function principalBalanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IIncentivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IIncentivePool {\n  event ClaimIncentive(address indexed user, uint256 claimedIncentive, uint256 userIncentiveIndex);\n\n  event UpdateIncentivePool(address indexed user, uint256 accruedIncentive, uint256 incentiveIndex);\n\n  event IncentivePoolEnded();\n\n  function initializeIncentivePool(address lToken) external;\n\n  function updateIncentivePool(address user) external;\n\n  function beforeTokenTransfer(address from, address to) external;\n\n  function claimIncentive() external;\n\n  function withdrawResidue() external;\n}\n"
    },
    "contracts/MoneyPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport './libraries/DataStruct.sol';\n\nimport './logic/Index.sol';\n\nimport './interfaces/IConnector.sol';\n\ncontract MoneyPoolStorage {\n  using Index for DataStruct.ReserveData;\n\n  mapping(address => DataStruct.ReserveData) internal _reserves;\n\n  mapping(uint256 => address) internal _reservesList;\n\n  uint256 internal _reserveCount;\n\n  uint256 internal _maxReserveCount;\n\n  IConnector internal _connector;\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../libraries/DataStruct.sol';\n\ninterface IInterestRateModel {\n  function calculateRates(\n    uint256 lTokenAssetBalance,\n    uint256 totalDTokenBalance,\n    uint256 depositAmount,\n    uint256 borrowAmount,\n    uint256 moneyPoolFactor\n  ) external view returns (uint256, uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test/MoneyPoolTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../MoneyPool.sol';\n\ncontract MoneyPoolTest is MoneyPool {\n  using Rate for DataStruct.ReserveData;\n\n  constructor(uint256 maxReserveCount_, address connector) MoneyPool(maxReserveCount_, connector) {}\n\n  function utilzedReserveForTest(\n    address asset,\n    uint256 totalSupply,\n    uint256 totalBorrow\n  ) external {\n    DataStruct.ReserveData storage reserve = _reserves[asset];\n\n    ILToken(reserve.lTokenAddress).mint(msg.sender, totalSupply, reserve.lTokenInterestIndex);\n    reserve.updateRates(asset, 0, 0);\n\n    IDToken(reserve.dTokenAddress).mint(msg.sender, msg.sender, totalBorrow, reserve.borrowAPY);\n    reserve.updateRates(asset, 0, 0);\n  }\n}\n"
    },
    "contracts/test/IndexTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../logic/Index.sol';\nimport '../MoneyPoolStorage.sol';\n\ncontract IndexTest is MoneyPoolStorage {\n  using Index for DataStruct.ReserveData;\n\n  function getLTokenInterestIndex(address asset) public view returns (uint256) {\n    return _reserves[asset].getLTokenInterestIndex();\n  }\n\n  function updateState(address asset) public {\n    _reserves[asset].updateState(asset);\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) public view returns (DataStruct.ReserveData memory) {\n    return _reserves[asset];\n  }\n}\n"
    },
    "contracts/LToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport './libraries/WadRayMath.sol';\n\nimport './interfaces/ILToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/IIncentivePool.sol';\n\n/**\n * @title ELYFI LToken\n * @author ELYSIA\n * @notice LTokens are the basis for repayment of loans and interest on their deposits. When Money Pool\n * investors deposit or withdraw assets from the Money Pool Contract, the Smart Contract automatically\n * issues or destroys LTokens accordingly.\n * @dev LTokens comply with the ERC20 token standard. Some functions are restricted to the general user.\n */\ncontract LToken is ILToken, ERC20 {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IMoneyPool internal _moneyPool;\n  IIncentivePool internal _incentivePool;\n  address internal _underlyingAsset;\n\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset,\n    IIncentivePool incentivePool,\n    string memory name,\n    string memory symbol\n  ) ERC20(name, symbol) {\n    _moneyPool = moneyPool;\n    _underlyingAsset = underlyingAsset;\n    _incentivePool = incentivePool;\n  }\n\n  function mint(\n    address account,\n    uint256 amount,\n    uint256 index\n  ) external override onlyMoneyPool {\n    uint256 implicitBalance = amount.rayDiv(index);\n\n    require(amount != 0, 'LTokenInvalidMintAmount');\n\n    _incentivePool.updateIncentivePool(account);\n    _mint(account, implicitBalance);\n\n    emit Mint(account, implicitBalance, index);\n  }\n\n  function burn(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 index\n  ) external override onlyMoneyPool {\n    uint256 implicitBalance = amount.rayDiv(index);\n\n    require(amount != 0, 'LTokenInvalidBurnAmount');\n\n    _incentivePool.updateIncentivePool(account);\n    _burn(account, implicitBalance);\n\n    IERC20(_underlyingAsset).safeTransfer(receiver, amount);\n\n    emit Burn(account, receiver, implicitBalance, index);\n  }\n\n  /**\n   * @return Returns implicit balance multipied by ltoken interest index\n   **/\n  function balanceOf(address account) public view override(IERC20, ERC20) returns (uint256) {\n    return super.balanceOf(account).rayMul(_moneyPool.getLTokenInterestIndex(_underlyingAsset));\n  }\n\n  function implicitBalanceOf(address account) external view override returns (uint256) {\n    return super.balanceOf(account);\n  }\n\n  function implicitTotalSupply() public view override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  function totalSupply() public view override(IERC20, ERC20) returns (uint256) {\n    return super.totalSupply().rayMul(_moneyPool.getLTokenInterestIndex(_underlyingAsset));\n  }\n\n  /**\n   * @dev Transfers the underlying asset to receiver.\n   * @param receiver The recipient of the underlying asset\n   * @param amount The amount getting transferred\n   **/\n  function transferUnderlyingTo(address receiver, uint256 amount) external override onlyMoneyPool {\n    IERC20(_underlyingAsset).safeTransfer(receiver, amount);\n  }\n\n  /**\n   * @dev Transfers LToken\n   * @param from The from address\n   * @param to The recipient of LToken\n   * @param amount The amount getting transferred, but actual amount is implicit balance\n   * @param validate If true, validate and finalize transfer\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount,\n    bool validate\n  ) internal {\n    uint256 index = _moneyPool.getLTokenInterestIndex(_underlyingAsset);\n    validate;\n    _incentivePool.beforeTokenTransfer(from, to);\n    super._transfer(from, to, amount.rayDiv(index));\n  }\n\n  /**\n   * @dev Overriding ERC20 _transfer for reflecting implicit balance\n   * @param from The from address\n   * @param to The recipient of LToken\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    _transfer(from, to, amount, true);\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function getUnderlyingAsset() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  function updateIncentivePool(address newIncentivePool) external override onlyMoneyPool {\n    _incentivePool = IIncentivePool(newIncentivePool);\n  }\n\n  modifier onlyMoneyPool {\n    require(_msgSender() == address(_moneyPool), 'OnlyMoneyPool');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/LTokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../LToken.sol';\n\ncontract LTokenTest is LToken {\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset,\n    IIncentivePool incentivePool,\n    string memory name,\n    string memory symbol\n  ) LToken(moneyPool, underlyingAsset, incentivePool, name, symbol) {}\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './libraries/WadRayMath.sol';\n\nimport './interfaces/IInterestRateModel.sol';\n\nimport './InterestRateModelStorage.sol';\n\n/**\n * @title ELYFI InterestRateModel\n * @author ELYSIA\n * @notice Interest rates model in ELYFI. ELYFI's interest rates are determined by algorithms.\n * When borrowing demand increases, borrowing interest and MoneyPool ROI increase,\n * suppressing excessove borrowing demand and inducing depositors to supply liquidity.\n * Therefore, ELYFI's interest rates are influenced by the Money Pool `utilizationRatio`.\n * The Money Pool utilization ratio is a variable representing the current borrowing\n * and deposit status of the Money Pool. The interest rates of ELYFI exhibits some form of kink.\n * They sharply change at some defined threshold, `optimalUtilazationRate`.\n */\ncontract InterestRateModel is IInterestRateModel, InterestRateModelStorage {\n  using WadRayMath for uint256;\n\n  /**\n   * @param optimalUtilizationRate When the MoneyPool utilization ratio exceeds this parameter,\n   * `optimalUtilizationRate`, the kinked rates model adjusts interests.\n   * @param borrowRateBase The base interest rate.\n   * @param borrowRateOptimal Interest rate when the Money Pool utilization ratio is optimal\n   * @param borrowRateMax Interest rate when the Money Pool utilization ratio is 1\n   */\n  constructor(\n    uint256 optimalUtilizationRate,\n    uint256 borrowRateBase,\n    uint256 borrowRateOptimal,\n    uint256 borrowRateMax\n  ) {\n    _optimalUtilizationRate = optimalUtilizationRate;\n    _borrowRateBase = borrowRateBase;\n    _borrowRateOptimal = borrowRateOptimal;\n    _borrowRateMax = borrowRateMax;\n  }\n\n  struct calculateRatesLocalVars {\n    uint256 totalDebt;\n    uint256 utilizationRate;\n    uint256 newBorrowAPY;\n    uint256 newDepositAPY;\n  }\n\n  /**\n   * @notice Calculates the interest rates.\n   * @dev\n   * Calculation Example\n   * Case1: under optimal U\n   * baseRate = 2%, util = 40%, optimalRate = 10%, optimalUtil = 80%\n   * result = 2+40*(10-2)/80 = 4%\n   * Case2: over optimal U\n   * optimalRate = 10%, util = 90%, maxRate = 100%, optimalUtil = 80%\n   * result = 10+(90-80)*(100-10)/(100-80) = 55%\n   * @param lTokenAssetBalance Total deposit amount\n   * @param totalDTokenBalance total loan amount\n   * @param depositAmount The liquidity added during the operation\n   * @param borrowAmount The liquidity taken during the operation\n   */\n  function calculateRates(\n    uint256 lTokenAssetBalance,\n    uint256 totalDTokenBalance,\n    uint256 depositAmount,\n    uint256 borrowAmount,\n    uint256 moneyPoolFactor\n  ) public view override returns (uint256, uint256) {\n    calculateRatesLocalVars memory vars;\n    moneyPoolFactor;\n\n    vars.totalDebt = totalDTokenBalance;\n\n    uint256 availableLiquidity = lTokenAssetBalance + depositAmount - borrowAmount;\n\n    vars.utilizationRate = vars.totalDebt == 0\n      ? 0\n      : vars.totalDebt.rayDiv(availableLiquidity + vars.totalDebt);\n\n    vars.newBorrowAPY = 0;\n\n    if (vars.utilizationRate <= _optimalUtilizationRate) {\n      vars.newBorrowAPY =\n        _borrowRateBase +\n        (\n          (_borrowRateOptimal - _borrowRateBase).rayDiv(_optimalUtilizationRate).rayMul(\n            vars.utilizationRate\n          )\n        );\n    } else {\n      vars.newBorrowAPY =\n        _borrowRateOptimal +\n        (\n          (_borrowRateMax - _borrowRateOptimal)\n          .rayDiv(WadRayMath.ray() - _optimalUtilizationRate)\n          .rayMul(vars.utilizationRate - _borrowRateOptimal)\n        );\n    }\n\n    vars.newDepositAPY = vars.newBorrowAPY.rayMul(vars.utilizationRate);\n\n    return (vars.newBorrowAPY, vars.newDepositAPY);\n  }\n}\n"
    },
    "contracts/InterestRateModelStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n * @title ELYFI InterestRateModel\n * @author ELYSIA\n */\ncontract InterestRateModelStorage {\n  uint256 internal _optimalUtilizationRate;\n\n  uint256 internal _borrowRateBase;\n\n  uint256 internal _borrowRateOptimal;\n\n  uint256 internal _borrowRateMax;\n}\n"
    },
    "contracts/IncentivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport './libraries/WadRayMath.sol';\nimport './interfaces/IIncentivePool.sol';\nimport './interfaces/IMoneyPool.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport 'hardhat/console.sol';\n\ncontract IncentivePool is IIncentivePool {\n  using WadRayMath for uint256;\n  using SafeERC20 for IERC20;\n\n  constructor(\n    IMoneyPool moneyPool,\n    address incentiveAsset,\n    uint256 amountPerSecond_\n  ) {\n    _moneyPool = moneyPool;\n    _incentiveAsset = incentiveAsset;\n    amountPerSecond = amountPerSecond_;\n    _owner = msg.sender;\n  }\n\n  address private _owner;\n\n  bool private _initialized;\n\n  IMoneyPool internal _moneyPool;\n\n  address internal _incentiveAsset;\n\n  uint256 internal _incentiveIndex;\n\n  uint256 internal _lastUpdateTimestamp;\n\n  mapping(address => uint256) internal _userIncentiveIndex;\n\n  mapping(address => uint256) internal _accruedIncentive;\n\n  uint256 public amountPerSecond;\n\n  address public lToken;\n\n  uint256 public endTimestamp;\n\n  function initializeIncentivePool(address lToken_) external override onlyMoneyPool {\n    require(!_initialized, 'AlreadyInitialized');\n    _initialized = true;\n    lToken = lToken_;\n    endTimestamp = block.timestamp + 180 * 1 days;\n  }\n\n  function isClosed() public view returns (bool) {\n    if (block.timestamp > endTimestamp) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Update user incentive index and last update timestamp in minting or burining lTokens.\n   */\n  function updateIncentivePool(address user) external override onlyLToken {\n    _accruedIncentive[user] = getUserIncentive(user);\n    _incentiveIndex = _userIncentiveIndex[user] = getIncentiveIndex();\n\n    if (isClosed()) {\n      _lastUpdateTimestamp = endTimestamp;\n      return;\n    }\n    _lastUpdateTimestamp = block.timestamp;\n\n    emit UpdateIncentivePool(user, _accruedIncentive[user], _incentiveIndex);\n  }\n\n  /**\n   * @notice If user transfered lToken, accrued reward will be updated\n   * and user index will be set to the current index\n   */\n  function beforeTokenTransfer(address from, address to) external override onlyLToken {\n    _accruedIncentive[from] = getUserIncentive(from);\n    _accruedIncentive[to] = getUserIncentive(to);\n    _userIncentiveIndex[from] = _userIncentiveIndex[to] = getIncentiveIndex();\n  }\n\n  function claimIncentive() external override {\n    address user = msg.sender;\n\n    uint256 accruedIncentive = getUserIncentive(user);\n\n    require(accruedIncentive > 0, 'NotEnoughUserAccruedIncentive');\n\n    _userIncentiveIndex[user] = getIncentiveIndex();\n\n    _accruedIncentive[user] = 0;\n\n    IERC20(_incentiveAsset).safeTransfer(user, accruedIncentive);\n\n    emit ClaimIncentive(user, accruedIncentive, _userIncentiveIndex[user]);\n  }\n\n  function getIncentiveIndex() public view returns (uint256) {\n    uint256 currentTimestamp = block.timestamp < endTimestamp ? block.timestamp : endTimestamp;\n    uint256 timeDiff = currentTimestamp - _lastUpdateTimestamp;\n    uint256 totalSupply = IERC20(lToken).totalSupply();\n\n    if (timeDiff == 0) {\n      return _incentiveIndex;\n    }\n\n    if (totalSupply == 0) {\n      return 0;\n    }\n\n    uint256 IncentiveIndexDiff = (timeDiff * amountPerSecond * 1e9) / totalSupply;\n\n    return _incentiveIndex + IncentiveIndexDiff;\n  }\n\n  function getUserIncentive(address user) public view returns (uint256) {\n    uint256 indexDiff = 0;\n\n    if (getIncentiveIndex() >= _userIncentiveIndex[user]) {\n      indexDiff = getIncentiveIndex() - _userIncentiveIndex[user];\n    }\n    uint256 balance = IERC20(lToken).balanceOf(user);\n\n    uint256 result = _accruedIncentive[user] + (balance * indexDiff) / 1e9;\n\n    return result;\n  }\n\n  function getUserIncentiveData(address user)\n    public\n    view\n    returns (\n      uint256 userIndex,\n      uint256 userReward,\n      uint256 userLTokenBalance\n    )\n  {\n    return (_userIncentiveIndex[user], _accruedIncentive[user], IERC20(lToken).balanceOf(user));\n  }\n\n  function getIncentivePoolData()\n    public\n    view\n    returns (uint256 incentiveIndex, uint256 lastUpdateTimestamp)\n  {\n    return (_incentiveIndex, _lastUpdateTimestamp);\n  }\n\n  function withdrawResidue() external override {\n    require(msg.sender == _owner, 'onlyAdmin');\n    require(isClosed(), 'OnlyClosed');\n    uint256 residue = IERC20(_incentiveAsset).balanceOf(address(this));\n    IERC20(_incentiveAsset).safeTransfer(_owner, residue);\n    emit IncentivePoolEnded();\n  }\n\n  modifier onlyMoneyPool {\n    require(msg.sender == address(_moneyPool), 'OnlyMoneyPool');\n    _;\n  }\n\n  modifier onlyLToken {\n    require(msg.sender == address(lToken), 'OnlyLToken');\n    _;\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/test/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/**\n * @notice This ERC20 is only for the testnet.\n */\ncontract ERC20Test is ERC20 {\n  constructor(\n    uint256 totalSupply_,\n    string memory name_,\n    string memory symbol_\n  ) ERC20(name_, symbol_) {\n    _mint(msg.sender, totalSupply_ / 2);\n    _mint(address(this), totalSupply_ / 2);\n  }\n\n  /**\n   * @notice The faucet is for testing ELYFI functions\n   */\n  function faucet() external {\n    _transfer(address(this), msg.sender, 10000 * 1e18);\n  }\n}\n"
    },
    "contracts/DataPipeline.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './libraries/DataStruct.sol';\n\nimport './interfaces/ILToken.sol';\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\nimport './interfaces/ITokenizer.sol';\n\n/**\n * @title ELYFI Data Pipeline\n * @author ELYSIA\n * @dev The data pipeline contract is to help integrating the data of user and reserve in ELYFI.\n * Each reserve has a seperate data pipeline.\n */\ncontract DataPipeline {\n  IMoneyPool public moneyPool;\n\n  constructor(address moneyPool_) {\n    moneyPool = IMoneyPool(moneyPool_);\n  }\n\n  struct UserDataLocalVars {\n    uint256 underlyingAssetBalance;\n    uint256 lTokenBalance;\n    uint256 implicitLtokenBalance;\n    uint256 dTokenBalance;\n    uint256 principalDTokenBalance;\n    uint256 averageRealAssetBorrowRate;\n    uint256 lastUpdateTimestamp;\n  }\n\n  /**\n   * @dev Returns the user's data for asset.\n   */\n  function getUserData(address asset, address user)\n    external\n    view\n    returns (UserDataLocalVars memory)\n  {\n    UserDataLocalVars memory vars;\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n\n    vars.underlyingAssetBalance = IERC20(asset).balanceOf(user);\n    vars.lTokenBalance = ILToken(reserve.lTokenAddress).balanceOf(user);\n    vars.implicitLtokenBalance = ILToken(reserve.lTokenAddress).implicitBalanceOf(user);\n    vars.dTokenBalance = IDToken(reserve.dTokenAddress).balanceOf(user);\n    vars.principalDTokenBalance = IDToken(reserve.dTokenAddress).principalBalanceOf(user);\n    vars.averageRealAssetBorrowRate = IDToken(reserve.dTokenAddress)\n    .getUserAverageRealAssetBorrowRate(user);\n    vars.lastUpdateTimestamp = IDToken(reserve.dTokenAddress).getUserLastUpdateTimestamp(user);\n\n    return vars;\n  }\n\n  struct ReserveDataLocalVars {\n    uint256 totalLTokenSupply;\n    uint256 implicitLTokenSupply;\n    uint256 lTokenInterestIndex;\n    uint256 principalDTokenSupply;\n    uint256 totalDTokenSupply;\n    uint256 averageRealAssetBorrowRate;\n    uint256 dTokenLastUpdateTimestamp;\n    uint256 borrowAPY;\n    uint256 depositAPY;\n    uint256 moneyPooLastUpdateTimestamp;\n  }\n\n  /**\n   * @dev Returns the reserve's data for asset.\n   */\n  function getReserveData(address asset) external view returns (ReserveDataLocalVars memory) {\n    ReserveDataLocalVars memory vars;\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n\n    vars.totalLTokenSupply = ILToken(reserve.lTokenAddress).totalSupply();\n    vars.implicitLTokenSupply = ILToken(reserve.lTokenAddress).implicitTotalSupply();\n    vars.lTokenInterestIndex = reserve.lTokenInterestIndex;\n    (\n      vars.principalDTokenSupply,\n      vars.totalDTokenSupply,\n      vars.averageRealAssetBorrowRate,\n      vars.dTokenLastUpdateTimestamp\n    ) = IDToken(reserve.dTokenAddress).getDTokenData();\n    vars.borrowAPY = reserve.borrowAPY;\n    vars.depositAPY = reserve.depositAPY;\n    vars.moneyPooLastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    return vars;\n  }\n\n  struct AssetBondStateDataLocalVars {\n    DataStruct.AssetBondState assetBondState;\n    address tokenOwner;\n    uint256 debtOnMoneyPool;\n    uint256 feeOnCollateralServiceProvider;\n  }\n\n  function getAssetBondStateData(address asset, uint256 tokenId)\n    external\n    view\n    returns (AssetBondStateDataLocalVars memory)\n  {\n    AssetBondStateDataLocalVars memory vars;\n\n    DataStruct.ReserveData memory reserve = moneyPool.getReserveData(asset);\n    DataStruct.AssetBondData memory assetBond = ITokenizer(reserve.tokenizerAddress)\n    .getAssetBondData(tokenId);\n\n    vars.assetBondState = assetBond.state;\n    vars.tokenOwner = ITokenizer(reserve.tokenizerAddress).ownerOf(tokenId);\n    (vars.debtOnMoneyPool, vars.feeOnCollateralServiceProvider) = ITokenizer(\n      reserve.tokenizerAddress\n    ).getAssetBondDebtData(tokenId);\n\n    return vars;\n  }\n}\n"
    },
    "contracts/DToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport './libraries/WadRayMath.sol';\nimport './libraries/Math.sol';\n\nimport './interfaces/IDToken.sol';\nimport './interfaces/IMoneyPool.sol';\n\n/**\n * @title DToken\n * @notice The DToken balance of borrower is the amount of money that the borrower\n * would be required to repay and seize the collateralized asset bond token.\n *\n * @author Aave\n **/\ncontract DToken is IDToken, Context {\n  using WadRayMath for uint256;\n\n  uint256 internal _totalAverageRealAssetBorrowRate;\n  mapping(address => uint256) internal _userLastUpdateTimestamp;\n  mapping(address => uint256) internal _userAverageRealAssetBorrowRate;\n  uint256 internal _lastUpdateTimestamp;\n\n  uint256 internal _totalSupply;\n  mapping(address => uint256) internal _balances;\n\n  string private _name;\n  string private _symbol;\n\n  IMoneyPool internal _moneyPool;\n  address internal _underlyingAsset;\n\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) {\n    _moneyPool = moneyPool;\n    _underlyingAsset = underlyingAsset_;\n\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the decimals of the token.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    recipient;\n    amount;\n    require(false, 'DTokenTransferNotAllowed');\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    sender;\n    recipient;\n    amount;\n    require(false, 'DTokenTransferFromNotAllowed');\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    owner;\n    spender;\n    require(false, 'DTokenAllowanceNotAllowed');\n    return 0;\n  }\n\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    spender;\n    amount;\n    require(false, 'DTokenApproveNotAllowed');\n    return true;\n  }\n\n  /**\n   * @dev Returns the average stable rate across all the stable rate debt\n   * @return the average stable rate\n   **/\n  function getTotalAverageRealAssetBorrowRate() external view virtual override returns (uint256) {\n    return _totalAverageRealAssetBorrowRate;\n  }\n\n  /**\n   * @dev Returns the timestamp of the last account action\n   * @return The last update timestamp\n   **/\n  function getUserLastUpdateTimestamp(address account)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _userLastUpdateTimestamp[account];\n  }\n\n  /**\n   * @dev Returns the stable rate of the account\n   * @param account The address of the account\n   * @return The stable rate of account\n   **/\n  function getUserAverageRealAssetBorrowRate(address account)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _userAverageRealAssetBorrowRate[account];\n  }\n\n  /**\n   * @dev Calculates the current account debt balance\n   * @return The accumulated debt of the account\n   **/\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    uint256 accountBalance = _balances[account];\n    uint256 stableRate = _userAverageRealAssetBorrowRate[account];\n\n    // strict equality is not dangerous here\n    // divide-before-multiply dangerous-strict-equalities\n    if (accountBalance == 0) {\n      return 0;\n    }\n    uint256 cumulatedInterest = Math.calculateCompoundedInterest(\n      stableRate,\n      _userLastUpdateTimestamp[account],\n      block.timestamp\n    );\n    return accountBalance.rayMul(cumulatedInterest);\n  }\n\n  struct MintLocalVars {\n    uint256 previousSupply;\n    uint256 nextSupply;\n    uint256 amountInRay;\n    uint256 newStableRate;\n    uint256 currentAvgStableRate;\n  }\n\n  /**\n   * @dev Mints debt token to the `receiver` address.\n   * -  Only callable by the LendingPool\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the principal debt\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `receiver` otherwise\n   * @param receiver The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address account,\n    address receiver,\n    uint256 amount,\n    uint256 rate\n  ) external override onlyMoneyPool {\n    MintLocalVars memory vars;\n\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(receiver);\n\n    vars.previousSupply = totalSupply();\n    vars.currentAvgStableRate = _totalAverageRealAssetBorrowRate;\n    vars.nextSupply = _totalSupply = vars.previousSupply + amount;\n\n    vars.amountInRay = amount.wadToRay();\n\n    (, vars.newStableRate) = Math.calculateRateInIncreasingBalance(\n      _userAverageRealAssetBorrowRate[receiver],\n      currentBalance,\n      amount,\n      rate\n    );\n\n    _userAverageRealAssetBorrowRate[receiver] = vars.newStableRate;\n\n    //solium-disable-next-line\n    _lastUpdateTimestamp = _userLastUpdateTimestamp[receiver] = block.timestamp;\n\n    // Calculates the updated average stable rate\n    (, vars.currentAvgStableRate) = Math.calculateRateInIncreasingBalance(\n      vars.currentAvgStableRate,\n      vars.previousSupply,\n      amount,\n      rate\n    );\n\n    _totalAverageRealAssetBorrowRate = vars.currentAvgStableRate;\n\n    _mint(receiver, amount + balanceIncrease);\n\n    emit Transfer(address(0), receiver, amount);\n\n    emit Mint(\n      account,\n      receiver,\n      amount + balanceIncrease,\n      currentBalance,\n      balanceIncrease,\n      vars.newStableRate,\n      vars.currentAvgStableRate,\n      vars.nextSupply\n    );\n  }\n\n  /**\n   * @dev Burns debt of `account`\n   * @param account The address of the account getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address account, uint256 amount) external override onlyMoneyPool {\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(account);\n\n    uint256 previousSupply = totalSupply();\n    uint256 newAvgStableRate = 0;\n    uint256 nextSupply = 0;\n    uint256 userStableRate = _userAverageRealAssetBorrowRate[account];\n\n    // Since the total supply and each single account debt accrue separately,\n    // there might be accumulation errors so that the last borrower repaying\n    // mght actually try to repay more than the available debt supply.\n    // In this case we simply set the total supply and the avg stable rate to 0\n    if (previousSupply <= amount) {\n      _totalAverageRealAssetBorrowRate = 0;\n      _totalSupply = 0;\n    } else {\n      nextSupply = _totalSupply = previousSupply - amount;\n      uint256 firstTerm = _totalAverageRealAssetBorrowRate.rayMul(previousSupply.wadToRay());\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n      // For the same reason described above, when the last account is repaying it might\n      // happen that account rate * account balance > avg rate * total supply. In that case,\n      // we simply set the avg rate to 0\n      if (secondTerm >= firstTerm) {\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = _totalSupply = 0;\n      } else {\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = (firstTerm - secondTerm).rayDiv(\n          nextSupply.wadToRay()\n        );\n      }\n    }\n\n    if (amount == currentBalance) {\n      _userAverageRealAssetBorrowRate[account] = 0;\n      _userLastUpdateTimestamp[account] = 0;\n    } else {\n      //solium-disable-next-line\n      _userLastUpdateTimestamp[account] = block.timestamp;\n    }\n    //solium-disable-next-line\n    _lastUpdateTimestamp = block.timestamp;\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      _mint(account, amountToMint);\n      emit Mint(\n        account,\n        account,\n        amountToMint,\n        currentBalance,\n        balanceIncrease,\n        userStableRate,\n        newAvgStableRate,\n        nextSupply\n      );\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      _burn(account, amountToBurn);\n      emit Burn(\n        account,\n        amountToBurn,\n        currentBalance,\n        balanceIncrease,\n        newAvgStableRate,\n        nextSupply\n      );\n    }\n\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Calculates the increase in balance since the last account interaction\n   * @param account The address of the account for which the interest is being accumulated\n   * @return The principal principal balance, the new principal balance and the balance increase\n   **/\n  function _calculateBalanceIncrease(address account)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 previousprincipalBalance = _balances[account];\n\n    // strict equality is not dangerous here\n    // divide-before-multiply dangerous-strict-equalities\n    if (previousprincipalBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    // Calculation of the accrued interest since the last accumulation\n    uint256 balanceIncrease = balanceOf(account) - previousprincipalBalance;\n\n    return (previousprincipalBalance, previousprincipalBalance + balanceIncrease, balanceIncrease);\n  }\n\n  /**\n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n   **/\n  function getDTokenData()\n    public\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\n    return (_totalSupply, _calcTotalSupply(avgRate), avgRate, _lastUpdateTimestamp);\n  }\n\n  /**\n   * @dev Returns the the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\n    return (_calcTotalSupply(avgRate), avgRate);\n  }\n\n  /**\n   * @dev Returns the total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    return _calcTotalSupply(_totalAverageRealAssetBorrowRate);\n  }\n\n  /**\n   * @dev Returns the timestamp at which the total supply was updated\n   **/\n  function getTotalSupplyLastUpdated() public view override returns (uint256) {\n    return _lastUpdateTimestamp;\n  }\n\n  /**\n   * @dev Returns the principal debt balance of the account from\n   * @param account The account's address\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function principalBalanceOf(address account) external view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this aToken is used\n   **/\n  function POOL() public view returns (IMoneyPool) {\n    return _moneyPool;\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contracts\n   **/\n  function _getMoneyPool() internal view returns (IMoneyPool) {\n    return _moneyPool;\n  }\n\n  /**\n   * @dev Calculates the total supply\n   * @param avgRate The average rate at which the total supply increases\n   * @return The debt balance of the account since the last burn/mint action\n   **/\n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n    uint256 principalSupply = _totalSupply;\n\n    // strict equality is not dangerous here\n    // divide-before-multiply dangerous-strict-equalities\n    if (principalSupply == 0) {\n      return 0;\n    }\n\n    uint256 cumulatedInterest = Math.calculateCompoundedInterest(\n      avgRate,\n      _lastUpdateTimestamp,\n      block.timestamp\n    );\n\n    return principalSupply.rayMul(cumulatedInterest);\n  }\n\n  /**\n   * @dev Mints stable debt tokens to an account\n   * @param account The account receiving the debt tokens\n   * @param amount The amount being minted\n   **/\n  function _mint(address account, uint256 amount) internal {\n    uint256 oldAccountBalance = _balances[account];\n    _balances[account] = oldAccountBalance + amount;\n  }\n\n  /**\n   * @dev Burns stable debt tokens of an account\n   * @param account The account getting his debt burned\n   * @param amount The amount being burned\n   **/\n  function _burn(address account, uint256 amount) internal {\n    uint256 oldAccountBalance = _balances[account];\n    _balances[account] = oldAccountBalance - amount;\n  }\n\n  modifier onlyMoneyPool {\n    require(_msgSender() == address(_moneyPool), 'OnlyMoneyPool');\n    _;\n  }\n}\n"
    },
    "contracts/test/DTokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport '../DToken.sol';\n\ncontract DTokenTest is DToken {\n  constructor(\n    IMoneyPool moneyPool,\n    address underlyingAsset_,\n    string memory name_,\n    string memory symbol_\n  ) DToken(moneyPool, underlyingAsset_, name_, symbol_) {}\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}